{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/5106777-240a8745b1e195f1.png","path":"images/5106777-240a8745b1e195f1.png","modified":0,"renderable":0},{"_id":"source/images/5106777-2a92ba6f32a3d3f9.png","path":"images/5106777-2a92ba6f32a3d3f9.png","modified":0,"renderable":0},{"_id":"source/images/5106777-87cfc19d337ca8d1.png","path":"images/5106777-87cfc19d337ca8d1.png","modified":0,"renderable":0},{"_id":"source/images/5106777-920c509dfffadc21.png","path":"images/5106777-920c509dfffadc21.png","modified":0,"renderable":0},{"_id":"source/images/5106777-a10e999040e7762c.png","path":"images/5106777-a10e999040e7762c.png","modified":0,"renderable":0},{"_id":"source/images/5106777-b79265113319f19c.png","path":"images/5106777-b79265113319f19c.png","modified":0,"renderable":0},{"_id":"source/images/5106777-cf08e99288003e68.png","path":"images/5106777-cf08e99288003e68.png","modified":0,"renderable":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1574144089916},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1574144089954},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1574144089955},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1574144089915},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1574144089956},{"_id":"source/_posts/ES6项目学习笔记（一）作用域-定义的补充完善.md","hash":"d2d3aae75d108ba1ac8541c8b46187b7cc704691","modified":1574064947234},{"_id":"source/_posts/ES6项目学习笔记（二）let和const-变量声明的扩展.md","hash":"cd490972862cb3dddb62f73a5b1ea6c535b2cf81","modified":1574064948461},{"_id":"source/_posts/ES项目学习笔记（三）赋值操作更简便-解构赋值.md","hash":"6f6f20c61afd999488a2170a08005569060c9759","modified":1575643544973},{"_id":"source/_posts/建立hexo个人博客过程记录.md","hash":"52c9ca3c935c230026576987b9c57d14f4054a96","modified":1568884596980},{"_id":"source/images/5106777-240a8745b1e195f1.png","hash":"9cb662bbd2a1ef33197dd44b3d962056a406c566","modified":1568883155403},{"_id":"source/images/5106777-2a92ba6f32a3d3f9.png","hash":"cc7c97900a7d184dc01650352336fbb5d62f6e7d","modified":1568883159173},{"_id":"source/images/5106777-87cfc19d337ca8d1.png","hash":"e3c2bc13f9b6ff8275d6887233f0837a24a9639c","modified":1568883172113},{"_id":"source/images/5106777-920c509dfffadc21.png","hash":"0013a7bf8a277a72426d1cf4658077c3b69f508a","modified":1568883167224},{"_id":"source/images/5106777-a10e999040e7762c.png","hash":"ee42b4d7f54ca6d1a9c1eecd6003d057de610f43","modified":1568883188501},{"_id":"source/images/5106777-b79265113319f19c.png","hash":"7dd613485348cdaccc7791686c70ed26fd241b6f","modified":1568883163578},{"_id":"source/images/5106777-cf08e99288003e68.png","hash":"c2a97b06e65637a428b1685f26b04f0fbc8a060a","modified":1568883192300},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1574144089918},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1574144089919},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1574144089920},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1574144089920},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1574144089921},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1574144089917},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1574144089921},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1574144089923},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1574144089924},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1574144089924},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1568870269277},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1568870269285},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1574144089951},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1568870269312},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1568870269321},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1568870269329},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1574144089958},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1574144089923},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1568870269294},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1574144089918},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1574144089929},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1574144089931},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"f4370d55f751ef47b426713690fb55b669c9f0b0","modified":1574144089930},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1574144089930},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1574144089933},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1574144089933},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1574144089934},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1574144089934},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1574144089939},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1574144089937},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1574144089944},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1574144089946},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1574144089946},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1574144089945},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1574144089948},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1574144089947},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1574144089957},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1574144089974},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1568870269597},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1568870269605},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1568870269631},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1568870269622},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1568870269641},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1574144089969},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1574144089988},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1574144089989},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1574144089992},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1574144089991},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1568870269614},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1574144089939},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1574144089941},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1574144089941},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1574144089941},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1574144089942},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1574144089938},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1574144089959},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1574144089963},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1574144089962},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1574144089964},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1574144089966},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1574144089966},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1574144089967},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1574144089968},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1574144089968},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1574144089965},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1574144089960},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1574144089962},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1574144089986},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1574144089985},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1568870269652},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1574144089986},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1574144089988},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1568870269514},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1574144089988},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1568870269521},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1568870269553},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1568870269542},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1568870269570},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1574144089973},{"_id":"public/2019/09/19/建立hexo个人博客过程记录/index.html","hash":"65ede3622f512f729181f1bc364d8f90cb6c32a4","modified":1574075038158},{"_id":"public/archives/index.html","hash":"e653192e156ed5e850f5c2a039b00f8940f7c9c4","modified":1574075038158},{"_id":"public/archives/2019/index.html","hash":"97d47253f1380a51dbf0e19b1ccd0359d95a62e7","modified":1574075038226},{"_id":"public/archives/2019/09/index.html","hash":"cf967183d1d44ffc26783c0ab2d25f8b6a659e93","modified":1574075038227},{"_id":"public/2019/11/18/ES项目学习笔记（三）赋值操作更简便-解构赋值/index.html","hash":"dfbe29d2820dbb8a4e375557c3c5b8b061476097","modified":1575716974298},{"_id":"public/2019/11/18/ES6项目学习笔记（二）let和const-变量声明的扩展/index.html","hash":"a984f479a2cecc069456d024e6d40a57802bc71f","modified":1574075038236},{"_id":"public/2019/11/18/ES6项目学习笔记（一）作用域-定义的补充完善/index.html","hash":"d9adbf4c3ad8d166f66c2a5556a6efe4be107d9c","modified":1574075038236},{"_id":"public/archives/2019/11/index.html","hash":"6cf16bb9c011b38a5c7e8d4eb364a9d4b31560c2","modified":1574075038236},{"_id":"public/index.html","hash":"4822eb0ed926adacf908fba9dc80de74a8cdc3a9","modified":1575716974298},{"_id":"public/images/5106777-2a92ba6f32a3d3f9.png","hash":"cc7c97900a7d184dc01650352336fbb5d62f6e7d","modified":1574075038240},{"_id":"public/images/5106777-240a8745b1e195f1.png","hash":"9cb662bbd2a1ef33197dd44b3d962056a406c566","modified":1574075038240},{"_id":"public/images/5106777-87cfc19d337ca8d1.png","hash":"e3c2bc13f9b6ff8275d6887233f0837a24a9639c","modified":1574075038240},{"_id":"public/images/5106777-a10e999040e7762c.png","hash":"ee42b4d7f54ca6d1a9c1eecd6003d057de610f43","modified":1574075038241},{"_id":"public/images/5106777-b79265113319f19c.png","hash":"7dd613485348cdaccc7791686c70ed26fd241b6f","modified":1574075038241},{"_id":"public/images/5106777-cf08e99288003e68.png","hash":"c2a97b06e65637a428b1685f26b04f0fbc8a060a","modified":1574075038241},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1574075038241},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1574075038241},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1574075038241},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1574075038241},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1574075038241},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1574075038241},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1574075038242},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1574075038242},{"_id":"public/images/5106777-920c509dfffadc21.png","hash":"0013a7bf8a277a72426d1cf4658077c3b69f508a","modified":1574075039157},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1574075039158},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1574075039160},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1574075039160},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1574075039165},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1574075039165},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1574075039165},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1574075039166},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1574075039166},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1574075039166},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1574075039166},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1574075039166},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1574075039166},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1574075039166},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1575716975128},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1574075039239}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"ES6项目学习笔记（一）作用域 定义的补充完善","date":"2019-11-18T08:13:20.000Z","_content":"作用域是什么？\n抱着这个疑问，咱们不妨先看看下面的一段代码\n```\nvar name = 'tony';\nfunction hello(age){\n\tconsole.log(name);\n\tconsole.log(age);\n\tconsole.log(fullName);\n}\nhello();\n//tony\n//undefined\n//fullName is not defined\n```\n![实际运行结果](https://upload-images.jianshu.io/upload_images/5106777-26d49a73643e41b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n如果不了解作用域的看到代码可能会和我一样疑惑，为什么fullname“no defined”而age是\"undefined\"，有什么区别，以及为啥是\"no defined\"？\n有了这样的疑问我们再来看看我们所看到的一些解释：\n![作用域解释1](https://upload-images.jianshu.io/upload_images/5106777-482ac5610c5afe2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![作用域解释2](https://upload-images.jianshu.io/upload_images/5106777-9fe6c719aba92a08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n从这个两个解释里面我们可以提取出来两个要点，**规则** **集合**\n\n规则其实不难理解，就如同我们人在社会中一样，受到各种规则限制，而在js中处处存在的变量，也同样受到一套规则所限，同样有“生老病死”（变量生命周期），同样有自己的“人生轨迹”（作用域链）。\n在js中变量所受的作用域规则主要有了 **全局作用域**，**局部作用域**，**块状作用域**，**动态作用域**，\n\n这些作用域在上面的代码就有体现，我们可以先从我们最容易看懂的name变量入手，变量name是在整个代码中的最外层的,即在**函数外**,**代码块``{}``外**(es6新增)的,这就是全局作用域.\n我们说作用域是变量在整个js代码中运行的规则，这时候name在全局作用域的规则下就是：**网页中所有脚本和函数均可使用**，\n![全局作用域声明的变量可以在函数内部修改](https://upload-images.jianshu.io/upload_images/5106777-b9b9a3344fec8a1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n我们再把这段代码修改一下，就可以通过对比加深对全局作用域的理解，同时知道什么是函数作用域了\n![全局作用域的变量和函数作用域的变量](https://upload-images.jianshu.io/upload_images/5106777-9fd270f73dd404b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n函数内部定义的变量age，**在函数内部定义**的，就是局部作用域，很明显，它的规则就是**只能在函数内部访问**，你看在其它函数内修改也改变不了内部27的事实。在修改age的这个函数内，涉及到了js的变量提升编译词法等（[看这里](https://www.runoob.com/js/js-hoisting.html)），你在函数外打印age这个变量是可以得到20的，这更加说明了作用域的存在，超出了作用域，即便名字相同，也是不同的变量。这也是由于不同作用域可访问的变量不同导致的，可以再看一眼作用域的解释：\n![作用域为可访问对象，变量，函数的集合](https://upload-images.jianshu.io/upload_images/5106777-2379c3518739236a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n在函数内部，存在的可访问变量有name，age，在函数内部查找不到name这个变量时，会找到上一层全局作用域中，而查找age时，在局部作用域中就找到了，所以不会再在全局作用域中进行查找。\n作为局部作用域定义的变量可以很好的受到保护，不在外部就被随意更改，但是比如年龄这个东西，总不能每年询问的时候总是那个岁数吧\n![局部作用域的变量每次访问都被重置](https://upload-images.jianshu.io/upload_images/5106777-5e7d373f0a1fc8c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n所以我们需要每次访问的时候让函数内部自己+1。类似这样\n![](https://upload-images.jianshu.io/upload_images/5106777-572053c97e185d26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nplus函数就包含了它上一层的作用域中的变量age，但由于plus函数也是局部作用域中，所以每次访问也是同样的值，如果能够将plus这个操作，做成类似全局作用域，那么每次执行就不会是重复的值了\n![闭包实际就是将局部作用域的集合调到全局作用域中，使局部作用域中的变量不被销毁](https://upload-images.jianshu.io/upload_images/5106777-5a8252d93a79bb09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n闭包是解决这个问题的一个方法，用立即执行函数返回的一个函数，成为了全局作用域下的一个变量集合，集合也可以是函数噢，所以，这个函数内部使用的变量，虽然是在局部作用域下的，但是却不会被销毁。\n\n这两个作用域基本上就是es5中经常使用的了，在es6中，新增了块状作用域， 起初我以为这个作用域的规则是针对所有变量的，但经过试验，这个规则主要配合`let`声明的变量使用，用来解决以前es5中一些场景下变量使用的作用域模糊不清的问题，比如常见的这种\n```\nfor(var i = 0;i < 3;i++){}\nconsole.log(i)  //3\n```\n如果换成let来声明i变量，就会报错`ReferenceError`，另外还有一种变量声明const，同样受此规则限制，所以，用let，const声明的变量仅在当前`{}`中可以访问。\n\n大概就说这些作用域了，总结：**作用域是变量在一段代码中的访问规则，是可访问变量的集合**。","source":"_posts/ES6项目学习笔记（一）作用域-定义的补充完善.md","raw":"---\ntitle: ES6项目学习笔记（一）作用域 定义的补充完善\ndate: 2019-11-18 16:13:20\ntags:\n---\n作用域是什么？\n抱着这个疑问，咱们不妨先看看下面的一段代码\n```\nvar name = 'tony';\nfunction hello(age){\n\tconsole.log(name);\n\tconsole.log(age);\n\tconsole.log(fullName);\n}\nhello();\n//tony\n//undefined\n//fullName is not defined\n```\n![实际运行结果](https://upload-images.jianshu.io/upload_images/5106777-26d49a73643e41b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n如果不了解作用域的看到代码可能会和我一样疑惑，为什么fullname“no defined”而age是\"undefined\"，有什么区别，以及为啥是\"no defined\"？\n有了这样的疑问我们再来看看我们所看到的一些解释：\n![作用域解释1](https://upload-images.jianshu.io/upload_images/5106777-482ac5610c5afe2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![作用域解释2](https://upload-images.jianshu.io/upload_images/5106777-9fe6c719aba92a08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n从这个两个解释里面我们可以提取出来两个要点，**规则** **集合**\n\n规则其实不难理解，就如同我们人在社会中一样，受到各种规则限制，而在js中处处存在的变量，也同样受到一套规则所限，同样有“生老病死”（变量生命周期），同样有自己的“人生轨迹”（作用域链）。\n在js中变量所受的作用域规则主要有了 **全局作用域**，**局部作用域**，**块状作用域**，**动态作用域**，\n\n这些作用域在上面的代码就有体现，我们可以先从我们最容易看懂的name变量入手，变量name是在整个代码中的最外层的,即在**函数外**,**代码块``{}``外**(es6新增)的,这就是全局作用域.\n我们说作用域是变量在整个js代码中运行的规则，这时候name在全局作用域的规则下就是：**网页中所有脚本和函数均可使用**，\n![全局作用域声明的变量可以在函数内部修改](https://upload-images.jianshu.io/upload_images/5106777-b9b9a3344fec8a1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n我们再把这段代码修改一下，就可以通过对比加深对全局作用域的理解，同时知道什么是函数作用域了\n![全局作用域的变量和函数作用域的变量](https://upload-images.jianshu.io/upload_images/5106777-9fd270f73dd404b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n函数内部定义的变量age，**在函数内部定义**的，就是局部作用域，很明显，它的规则就是**只能在函数内部访问**，你看在其它函数内修改也改变不了内部27的事实。在修改age的这个函数内，涉及到了js的变量提升编译词法等（[看这里](https://www.runoob.com/js/js-hoisting.html)），你在函数外打印age这个变量是可以得到20的，这更加说明了作用域的存在，超出了作用域，即便名字相同，也是不同的变量。这也是由于不同作用域可访问的变量不同导致的，可以再看一眼作用域的解释：\n![作用域为可访问对象，变量，函数的集合](https://upload-images.jianshu.io/upload_images/5106777-2379c3518739236a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n在函数内部，存在的可访问变量有name，age，在函数内部查找不到name这个变量时，会找到上一层全局作用域中，而查找age时，在局部作用域中就找到了，所以不会再在全局作用域中进行查找。\n作为局部作用域定义的变量可以很好的受到保护，不在外部就被随意更改，但是比如年龄这个东西，总不能每年询问的时候总是那个岁数吧\n![局部作用域的变量每次访问都被重置](https://upload-images.jianshu.io/upload_images/5106777-5e7d373f0a1fc8c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n所以我们需要每次访问的时候让函数内部自己+1。类似这样\n![](https://upload-images.jianshu.io/upload_images/5106777-572053c97e185d26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nplus函数就包含了它上一层的作用域中的变量age，但由于plus函数也是局部作用域中，所以每次访问也是同样的值，如果能够将plus这个操作，做成类似全局作用域，那么每次执行就不会是重复的值了\n![闭包实际就是将局部作用域的集合调到全局作用域中，使局部作用域中的变量不被销毁](https://upload-images.jianshu.io/upload_images/5106777-5a8252d93a79bb09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n闭包是解决这个问题的一个方法，用立即执行函数返回的一个函数，成为了全局作用域下的一个变量集合，集合也可以是函数噢，所以，这个函数内部使用的变量，虽然是在局部作用域下的，但是却不会被销毁。\n\n这两个作用域基本上就是es5中经常使用的了，在es6中，新增了块状作用域， 起初我以为这个作用域的规则是针对所有变量的，但经过试验，这个规则主要配合`let`声明的变量使用，用来解决以前es5中一些场景下变量使用的作用域模糊不清的问题，比如常见的这种\n```\nfor(var i = 0;i < 3;i++){}\nconsole.log(i)  //3\n```\n如果换成let来声明i变量，就会报错`ReferenceError`，另外还有一种变量声明const，同样受此规则限制，所以，用let，const声明的变量仅在当前`{}`中可以访问。\n\n大概就说这些作用域了，总结：**作用域是变量在一段代码中的访问规则，是可访问变量的集合**。","slug":"ES6项目学习笔记（一）作用域-定义的补充完善","published":1,"updated":"2019-11-18T08:15:47.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck34bmw840000ycrwn43id0ox","content":"<p>作用域是什么？<br>抱着这个疑问，咱们不妨先看看下面的一段代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &apos;tony&apos;;</span><br><span class=\"line\">function hello(age)&#123;</span><br><span class=\"line\">\tconsole.log(name);</span><br><span class=\"line\">\tconsole.log(age);</span><br><span class=\"line\">\tconsole.log(fullName);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello();</span><br><span class=\"line\">//tony</span><br><span class=\"line\">//undefined</span><br><span class=\"line\">//fullName is not defined</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5106777-26d49a73643e41b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"实际运行结果\"><br>如果不了解作用域的看到代码可能会和我一样疑惑，为什么fullname“no defined”而age是”undefined”，有什么区别，以及为啥是”no defined”？<br>有了这样的疑问我们再来看看我们所看到的一些解释：<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-482ac5610c5afe2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"作用域解释1\"><br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-9fe6c719aba92a08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"作用域解释2\"><br>从这个两个解释里面我们可以提取出来两个要点，<strong>规则</strong> <strong>集合</strong></p>\n<p>规则其实不难理解，就如同我们人在社会中一样，受到各种规则限制，而在js中处处存在的变量，也同样受到一套规则所限，同样有“生老病死”（变量生命周期），同样有自己的“人生轨迹”（作用域链）。<br>在js中变量所受的作用域规则主要有了 <strong>全局作用域</strong>，<strong>局部作用域</strong>，<strong>块状作用域</strong>，<strong>动态作用域</strong>，</p>\n<p>这些作用域在上面的代码就有体现，我们可以先从我们最容易看懂的name变量入手，变量name是在整个代码中的最外层的,即在<strong>函数外</strong>,<strong>代码块<code>{}</code>外</strong>(es6新增)的,这就是全局作用域.<br>我们说作用域是变量在整个js代码中运行的规则，这时候name在全局作用域的规则下就是：<strong>网页中所有脚本和函数均可使用</strong>，<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-b9b9a3344fec8a1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"全局作用域声明的变量可以在函数内部修改\"><br>我们再把这段代码修改一下，就可以通过对比加深对全局作用域的理解，同时知道什么是函数作用域了<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-9fd270f73dd404b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"全局作用域的变量和函数作用域的变量\"><br>函数内部定义的变量age，<strong>在函数内部定义</strong>的，就是局部作用域，很明显，它的规则就是<strong>只能在函数内部访问</strong>，你看在其它函数内修改也改变不了内部27的事实。在修改age的这个函数内，涉及到了js的变量提升编译词法等（<a href=\"https://www.runoob.com/js/js-hoisting.html\" target=\"_blank\" rel=\"noopener\">看这里</a>），你在函数外打印age这个变量是可以得到20的，这更加说明了作用域的存在，超出了作用域，即便名字相同，也是不同的变量。这也是由于不同作用域可访问的变量不同导致的，可以再看一眼作用域的解释：<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-2379c3518739236a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"作用域为可访问对象，变量，函数的集合\"><br>在函数内部，存在的可访问变量有name，age，在函数内部查找不到name这个变量时，会找到上一层全局作用域中，而查找age时，在局部作用域中就找到了，所以不会再在全局作用域中进行查找。<br>作为局部作用域定义的变量可以很好的受到保护，不在外部就被随意更改，但是比如年龄这个东西，总不能每年询问的时候总是那个岁数吧<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-5e7d373f0a1fc8c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"局部作用域的变量每次访问都被重置\"><br>所以我们需要每次访问的时候让函数内部自己+1。类似这样<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-572053c97e185d26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt><br>plus函数就包含了它上一层的作用域中的变量age，但由于plus函数也是局部作用域中，所以每次访问也是同样的值，如果能够将plus这个操作，做成类似全局作用域，那么每次执行就不会是重复的值了<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-5a8252d93a79bb09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"闭包实际就是将局部作用域的集合调到全局作用域中，使局部作用域中的变量不被销毁\"><br>闭包是解决这个问题的一个方法，用立即执行函数返回的一个函数，成为了全局作用域下的一个变量集合，集合也可以是函数噢，所以，这个函数内部使用的变量，虽然是在局部作用域下的，但是却不会被销毁。</p>\n<p>这两个作用域基本上就是es5中经常使用的了，在es6中，新增了块状作用域， 起初我以为这个作用域的规则是针对所有变量的，但经过试验，这个规则主要配合<code>let</code>声明的变量使用，用来解决以前es5中一些场景下变量使用的作用域模糊不清的问题，比如常见的这种</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(var i = 0;i &lt; 3;i++)&#123;&#125;</span><br><span class=\"line\">console.log(i)  //3</span><br></pre></td></tr></table></figure>\n\n<p>如果换成let来声明i变量，就会报错<code>ReferenceError</code>，另外还有一种变量声明const，同样受此规则限制，所以，用let，const声明的变量仅在当前<code>{}</code>中可以访问。</p>\n<p>大概就说这些作用域了，总结：<strong>作用域是变量在一段代码中的访问规则，是可访问变量的集合</strong>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>作用域是什么？<br>抱着这个疑问，咱们不妨先看看下面的一段代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &apos;tony&apos;;</span><br><span class=\"line\">function hello(age)&#123;</span><br><span class=\"line\">\tconsole.log(name);</span><br><span class=\"line\">\tconsole.log(age);</span><br><span class=\"line\">\tconsole.log(fullName);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello();</span><br><span class=\"line\">//tony</span><br><span class=\"line\">//undefined</span><br><span class=\"line\">//fullName is not defined</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5106777-26d49a73643e41b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"实际运行结果\"><br>如果不了解作用域的看到代码可能会和我一样疑惑，为什么fullname“no defined”而age是”undefined”，有什么区别，以及为啥是”no defined”？<br>有了这样的疑问我们再来看看我们所看到的一些解释：<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-482ac5610c5afe2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"作用域解释1\"><br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-9fe6c719aba92a08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"作用域解释2\"><br>从这个两个解释里面我们可以提取出来两个要点，<strong>规则</strong> <strong>集合</strong></p>\n<p>规则其实不难理解，就如同我们人在社会中一样，受到各种规则限制，而在js中处处存在的变量，也同样受到一套规则所限，同样有“生老病死”（变量生命周期），同样有自己的“人生轨迹”（作用域链）。<br>在js中变量所受的作用域规则主要有了 <strong>全局作用域</strong>，<strong>局部作用域</strong>，<strong>块状作用域</strong>，<strong>动态作用域</strong>，</p>\n<p>这些作用域在上面的代码就有体现，我们可以先从我们最容易看懂的name变量入手，变量name是在整个代码中的最外层的,即在<strong>函数外</strong>,<strong>代码块<code>{}</code>外</strong>(es6新增)的,这就是全局作用域.<br>我们说作用域是变量在整个js代码中运行的规则，这时候name在全局作用域的规则下就是：<strong>网页中所有脚本和函数均可使用</strong>，<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-b9b9a3344fec8a1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"全局作用域声明的变量可以在函数内部修改\"><br>我们再把这段代码修改一下，就可以通过对比加深对全局作用域的理解，同时知道什么是函数作用域了<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-9fd270f73dd404b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"全局作用域的变量和函数作用域的变量\"><br>函数内部定义的变量age，<strong>在函数内部定义</strong>的，就是局部作用域，很明显，它的规则就是<strong>只能在函数内部访问</strong>，你看在其它函数内修改也改变不了内部27的事实。在修改age的这个函数内，涉及到了js的变量提升编译词法等（<a href=\"https://www.runoob.com/js/js-hoisting.html\" target=\"_blank\" rel=\"noopener\">看这里</a>），你在函数外打印age这个变量是可以得到20的，这更加说明了作用域的存在，超出了作用域，即便名字相同，也是不同的变量。这也是由于不同作用域可访问的变量不同导致的，可以再看一眼作用域的解释：<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-2379c3518739236a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"作用域为可访问对象，变量，函数的集合\"><br>在函数内部，存在的可访问变量有name，age，在函数内部查找不到name这个变量时，会找到上一层全局作用域中，而查找age时，在局部作用域中就找到了，所以不会再在全局作用域中进行查找。<br>作为局部作用域定义的变量可以很好的受到保护，不在外部就被随意更改，但是比如年龄这个东西，总不能每年询问的时候总是那个岁数吧<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-5e7d373f0a1fc8c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"局部作用域的变量每次访问都被重置\"><br>所以我们需要每次访问的时候让函数内部自己+1。类似这样<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-572053c97e185d26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt><br>plus函数就包含了它上一层的作用域中的变量age，但由于plus函数也是局部作用域中，所以每次访问也是同样的值，如果能够将plus这个操作，做成类似全局作用域，那么每次执行就不会是重复的值了<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-5a8252d93a79bb09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"闭包实际就是将局部作用域的集合调到全局作用域中，使局部作用域中的变量不被销毁\"><br>闭包是解决这个问题的一个方法，用立即执行函数返回的一个函数，成为了全局作用域下的一个变量集合，集合也可以是函数噢，所以，这个函数内部使用的变量，虽然是在局部作用域下的，但是却不会被销毁。</p>\n<p>这两个作用域基本上就是es5中经常使用的了，在es6中，新增了块状作用域， 起初我以为这个作用域的规则是针对所有变量的，但经过试验，这个规则主要配合<code>let</code>声明的变量使用，用来解决以前es5中一些场景下变量使用的作用域模糊不清的问题，比如常见的这种</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(var i = 0;i &lt; 3;i++)&#123;&#125;</span><br><span class=\"line\">console.log(i)  //3</span><br></pre></td></tr></table></figure>\n\n<p>如果换成let来声明i变量，就会报错<code>ReferenceError</code>，另外还有一种变量声明const，同样受此规则限制，所以，用let，const声明的变量仅在当前<code>{}</code>中可以访问。</p>\n<p>大概就说这些作用域了，总结：<strong>作用域是变量在一段代码中的访问规则，是可访问变量的集合</strong>。</p>\n"},{"title":"ES6项目学习笔记（二）let和const 变量声明的扩展","date":"2019-11-18T08:13:46.000Z","_content":"let，const和var一样，是对变量的一种声明方式，都可以用来声明变量。\n先说说let，用来**声明仅可在块状作用域中使用的变量**。直接上代码说：\n![var声明的变量不受块状作用域限制](https://upload-images.jianshu.io/upload_images/5106777-749435c595b5b095.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n所以，不在块状作用域用，let就没什么意义。\n另外,同一作用域内,不能用let反复声明同一个变量,会报错的\n![](https://upload-images.jianshu.io/upload_images/5106777-4a36eaaba24ca8ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n用*const*用来声明创建一个常量,除了同一作用域下不能反复声明,还不能重新赋值,这里的值指的是变量引用的内存地址,在引用内容是对象的情况下，可以改变对象里面的内容,看代码就清楚了:\n![](https://upload-images.jianshu.io/upload_images/5106777-bf8bb8d7ba540abb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n以上，有其它的再讨论补充。","source":"_posts/ES6项目学习笔记（二）let和const-变量声明的扩展.md","raw":"---\ntitle: ES6项目学习笔记（二）let和const 变量声明的扩展\ndate: 2019-11-18 16:13:46\ntags:\n---\nlet，const和var一样，是对变量的一种声明方式，都可以用来声明变量。\n先说说let，用来**声明仅可在块状作用域中使用的变量**。直接上代码说：\n![var声明的变量不受块状作用域限制](https://upload-images.jianshu.io/upload_images/5106777-749435c595b5b095.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n所以，不在块状作用域用，let就没什么意义。\n另外,同一作用域内,不能用let反复声明同一个变量,会报错的\n![](https://upload-images.jianshu.io/upload_images/5106777-4a36eaaba24ca8ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n用*const*用来声明创建一个常量,除了同一作用域下不能反复声明,还不能重新赋值,这里的值指的是变量引用的内存地址,在引用内容是对象的情况下，可以改变对象里面的内容,看代码就清楚了:\n![](https://upload-images.jianshu.io/upload_images/5106777-bf8bb8d7ba540abb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n以上，有其它的再讨论补充。","slug":"ES6项目学习笔记（二）let和const-变量声明的扩展","published":1,"updated":"2019-11-18T08:15:48.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck34bmw8a0001ycrwrdptg6jy","content":"<p>let，const和var一样，是对变量的一种声明方式，都可以用来声明变量。<br>先说说let，用来<strong>声明仅可在块状作用域中使用的变量</strong>。直接上代码说：<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-749435c595b5b095.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"var声明的变量不受块状作用域限制\"><br>所以，不在块状作用域用，let就没什么意义。<br>另外,同一作用域内,不能用let反复声明同一个变量,会报错的<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-4a36eaaba24ca8ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt><br>用<em>const</em>用来声明创建一个常量,除了同一作用域下不能反复声明,还不能重新赋值,这里的值指的是变量引用的内存地址,在引用内容是对象的情况下，可以改变对象里面的内容,看代码就清楚了:<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-bf8bb8d7ba540abb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt><br>以上，有其它的再讨论补充。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>let，const和var一样，是对变量的一种声明方式，都可以用来声明变量。<br>先说说let，用来<strong>声明仅可在块状作用域中使用的变量</strong>。直接上代码说：<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-749435c595b5b095.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"var声明的变量不受块状作用域限制\"><br>所以，不在块状作用域用，let就没什么意义。<br>另外,同一作用域内,不能用let反复声明同一个变量,会报错的<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-4a36eaaba24ca8ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt><br>用<em>const</em>用来声明创建一个常量,除了同一作用域下不能反复声明,还不能重新赋值,这里的值指的是变量引用的内存地址,在引用内容是对象的情况下，可以改变对象里面的内容,看代码就清楚了:<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-bf8bb8d7ba540abb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt><br>以上，有其它的再讨论补充。</p>\n"},{"title":"ES项目学习笔记（三）赋值操作更简便 解构赋值","date":"2019-11-18T08:16:55.000Z","_content":"用一个经常遇到的问题来说明这一赋值的好处之一，**对两个变量的值进行替换**，通常我们得另外声明一个变量来作为两个变量交换的媒介，而现在如下代码就可以解决：\n```\n{\n  let a=1;\n  let b=2;\n  [a,b]=[b,a];\n  console.log(a,b);  //2,1\n}\n```\n解构赋值上述的用法是对**数组的解构赋值**，总的来说结构赋值大致可以分为**数组解构赋值**，**对象解构赋值**，**字符解构赋值**，**数值和布尔解构赋值**，**函数参数解构赋值**。\n\n无论何种解构赋值，解构赋值表达式的左边部分，即**解构的目标**，而右边的值，即左边**解构的源**，都遵循一个左右互相匹配的规则，只要等号两边的模式相同，左边的变量就会被赋予对应的值。\n\n#### 数组解构赋值\n上述的代码就是数组解构赋值的**基本用法**。以下是数组解构赋值的其它使用方式\n```\n//嵌套\n{\n  let [a, [[b], c]] = [1, [[2], 3]];\n  console.log(a,b,c); //1,2,3\n}\n//可忽略\n{\n  let [a, , b] = [1, 2, 3];\n  console.log(a,b);\n}\n//剩余运算符\n{\n  let a,b,rest;\n  [a,b,...rest] = [1,2,3,4,5,6];\n  console.log(a,b,rest); //1,2,[4,5,6]\n}\n//不完全解构\n{\n\tlet [a,b] = [1,2,3];\n}\n```\n上述的变量全都可以成功赋值，也就是成功解构，但也有无法解构成功的，比如：\n```\nlet [a] = [];\nlet [b, d,...c] = [1];\nconsole.log(a);  //undefined\nconsole.log(b,d,c); //1,undefined,[]\n```\n当解构目标在解构的源对应位置找不到值,则无法成功解构,变量的值就会变成`undefined`,...剩余运算符的变量为`[]`.\n在实际开发场景中返回的值可能有多种情况,可能你想要的值在某个位置确实没有,那么还可以使用**默认值**。\n```\nlet [a,b = 1] = [1];\nconsole.log(a,b); //1,1\nlet [c = 1,d = 2] = [undefined,null];\nconsole.log(c,d); //1,null\n```\n*ES6 内部使用严格相等运算符（===），判断一个位置是否有值。只有当一个数组成员严格等于`undefined`，默认值才会生效*\n默认值可以引用解构赋值的其他变量，但该变量必须已经声明。\n```\nlet [a = 1, b = a] = [];     // a=1; b=1\nlet [a = 1, b = a] = [2];    // a=2; b=2\nlet [a = 1, b = a] = [1, 2]; // a=1; b=2\nlet [a = b, b = 1] = [];     // ReferenceError: b is not defined\n```\n如果解构的源不是数组，就会报错\n```\nlet [foo] = 1;\nlet [foo] = false;\nlet [foo] = NaN;\nlet [foo] = undefined;\nlet [foo] = null;\nlet [foo] = {};\n```\n#### 对象解构赋值\n对象解构赋值同样遵循左右互相匹配的规则，类似数组一样有嵌套，默认值等，但要注意的是**变量名称需要和对象中的属性值要对应，因为数组的位置相对应来说是有序的，而对象中是无序的，只能通过属性来作为位置查找。**如果要使用其它的变量名称，可以使用`:`重新指定变量名称，注意此时引用地址已被新变量接收,`:`左边的变量就没有地址了，再访问的话是空的，是真的输出为空的字符，在下面示例代码中有对应的写法：\n```\n//基本\n{\n  let {a,b} = {a:1,b:2}\n  console.log(a,b);\n  let {name:newName} = {name:'tony'}\n  console.log(name)//''\n  console.log(newName)//tony\n}\n//默认值\n{\n  let {x = 3} = {};\n  let {a,b = 2}={a:1};\n}\n//嵌套\n{\n  const obj = {\n    name:{\n      chinese_name:{\n        first_name:'Chen',\n        last_name:'chuhai'\n      },\n      english_name:{\n        first_name:'Chen',\n        last_name:'tony'\n      }\n    }\n  };\n  let {name,name:{chinese_name},name:{chinese_name:{last_name:my_name}}} = obj;\n  console.log(name);//{chinese_name: {...},english_name: {...}}\n  console.log(chinese_name);//{first_name: \"Chen\",last_name: \"chuhai\"}\n  console.log(my_name)//chuhai\n}\n```\n和数组一样，对象解构也有嵌套，只是这个嵌套容易让人犯晕，别怕，回顾着之前讲的，一层层剥析。\n先看解构赋值的左边，前面说了叫做解构的目标，第一个为name变量，这个很简单了，这个就对应着右边解构源叫做name的属性值，然后是第二个解构目标，根据左右匹配的规则，可以得出chinese_name就是右边解构源name属性值对象中chinese_name的属性值，最后第三个，last_name就是对应结构源上\"chuhai\"这个值了，只是用`:`重新指定了变量的名称为my_name。\n结构目标最后只有一个，即得出最后的变量只有一个，第二次和第三次过程中分别出现的name和chinese_name，只是得到解构目标过程中为了和解构源相匹配而出现的，这样说应该就能解决大部分人对在解构目标出现的多个变量的迷惑了（可能只是我刚一接触时有这种迷惑），那些不是最终的变量，而是为了**匹配解构源对应位置的**\n\n解构赋值也并不是一定需要声明变量来赋值的，还可以通过下面的方式进行赋值\n```\nlet obj = {};\nlet arr = [];\n({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });\nobj // {prop:123}\narr // [true]\n```\n代码很容易看明白，抛出一个注意点，解构赋值的表达式用了一个括号，为什么呢？\n因为不那么写会报错。解构赋值用的变量在之前有声明过，而`{}`恰好会被作为代码块理解,这样上下文出现两个相同名称的变量解析时就会报错，放在一个圆括号里面，就可以正确执行。详细原因请大家看[大神阮一峰es6入门--圆括号问题](https://es6.ruanyifeng.com/#docs/destructuring#%E5%9C%86%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98)\n对象解构赋值和数组差不多，有没有独特一点的？\n有的，对象的解构赋值还可以拿到继承的属性，然后数组是特殊的对象，其实也能用对象解构的方式来解构数组。上代码\n>//继承\nconst obj1 = {};\nconst obj2 = { foo: 'bar' };\nObject.setPrototypeOf(obj1, obj2);\nconst { foo } = obj1;// \"bar\"\n//数组解构\nlet arr = [1, 2, 3];\nlet {0 : first, [arr.length - 1] : last} = arr;\nfirst // 1\nlast // 3\n\n#### 字符串的解构赋值\n后面的几种解构赋值基本上也是从对象解构或者数组解构延伸出来的，字符串可以看成一个被分割为数组的对象，所以，可以这么用\n{\n  //作为数组\n  let [a,b,c,d] = 'tony';\n  console.log(a,b,c,d);//t o n y\n  //作为对象解构还能这么用\n  let {length} = 'tony';\n  console.log(length);//4\n}\n\n#### 数值和布尔解构赋值\n解构赋值按照左右匹配规则来说，只要解构的源有数值，有结构，那么都可以进行解构，关键是看以什么解构规则进行解构，除去上面的数组对象字符串，其它的只要能转成对象，有结构，有数值，就可以进行解构，像`undefined`和`null`没值没结构的，就无法进行解构了，而布尔和数值可以。\n{\n  //转为对象后继承了字符对象的toString方法\n  let {toString: s} = 123;\n  s === Number.prototype.toString // true\n  let {toString: s} = true;\n  s === Boolean.prototype.toString // true\n}\n#### 函数参数解构赋值\n这部分函数解构赋值并不是简单的这样\n```\n{\n  function f(){\n    return [1,2]\n  }\n  let a,b;\n  [a,b]=f();\n  console.log(a,b);\n}\n```\n这样实际是拿函数的执行结果来进行解构赋值太小儿科，我也曾想过为什么不能是`{} = f`这样的解构赋值，方法里面虽然有结构有内容，但是，谁能告诉怎么个一一对应法，这不可能，所以，只能拿方法的传参讲讲了。\n```\n{\n  function add([a, b]){\n    return a + b;\n  }\n  console.log(add([1, 2])) // 3\n  console.log([[1, 2], [3, 4]].map(([a, b]) => a + b)) //[3,7];\n}\n```\n在传参的过程中进行解构赋值，原理和前面讲的解构赋值是一样的。\n\n至此结构赋值的类型都说完了，回到最初说明这一运算的用途，除了交换变量，还有其它的用途，在此一一列举：\n至此结构赋值的类型都说完了，回到最初说明这一运算的用途，除了交换变量，还有其它的用途，在此一一列举：\n- 交换变量\n- 处理函数返回值(见上述函数参数解构赋值的第一段代码)\n- 处理函数传参(还是见上述函数参数解构赋值的代码)\n- 处理JSON数据\n- 函数参数的默认值\n- 遍历 Map 结构\n- 引入模块的指定方法\n```\n  import { loginHtml, loginResultPage, userWxBinding, consolidatedAccountContent} from '../../html/login';\n```\n以上为解构赋值的笔记内容，如有补充和需探讨的，欢迎留言评论~","source":"_posts/ES项目学习笔记（三）赋值操作更简便-解构赋值.md","raw":"---\ntitle: ES项目学习笔记（三）赋值操作更简便 解构赋值\ndate: 2019-11-18 16:16:55\ntags:\n---\n用一个经常遇到的问题来说明这一赋值的好处之一，**对两个变量的值进行替换**，通常我们得另外声明一个变量来作为两个变量交换的媒介，而现在如下代码就可以解决：\n```\n{\n  let a=1;\n  let b=2;\n  [a,b]=[b,a];\n  console.log(a,b);  //2,1\n}\n```\n解构赋值上述的用法是对**数组的解构赋值**，总的来说结构赋值大致可以分为**数组解构赋值**，**对象解构赋值**，**字符解构赋值**，**数值和布尔解构赋值**，**函数参数解构赋值**。\n\n无论何种解构赋值，解构赋值表达式的左边部分，即**解构的目标**，而右边的值，即左边**解构的源**，都遵循一个左右互相匹配的规则，只要等号两边的模式相同，左边的变量就会被赋予对应的值。\n\n#### 数组解构赋值\n上述的代码就是数组解构赋值的**基本用法**。以下是数组解构赋值的其它使用方式\n```\n//嵌套\n{\n  let [a, [[b], c]] = [1, [[2], 3]];\n  console.log(a,b,c); //1,2,3\n}\n//可忽略\n{\n  let [a, , b] = [1, 2, 3];\n  console.log(a,b);\n}\n//剩余运算符\n{\n  let a,b,rest;\n  [a,b,...rest] = [1,2,3,4,5,6];\n  console.log(a,b,rest); //1,2,[4,5,6]\n}\n//不完全解构\n{\n\tlet [a,b] = [1,2,3];\n}\n```\n上述的变量全都可以成功赋值，也就是成功解构，但也有无法解构成功的，比如：\n```\nlet [a] = [];\nlet [b, d,...c] = [1];\nconsole.log(a);  //undefined\nconsole.log(b,d,c); //1,undefined,[]\n```\n当解构目标在解构的源对应位置找不到值,则无法成功解构,变量的值就会变成`undefined`,...剩余运算符的变量为`[]`.\n在实际开发场景中返回的值可能有多种情况,可能你想要的值在某个位置确实没有,那么还可以使用**默认值**。\n```\nlet [a,b = 1] = [1];\nconsole.log(a,b); //1,1\nlet [c = 1,d = 2] = [undefined,null];\nconsole.log(c,d); //1,null\n```\n*ES6 内部使用严格相等运算符（===），判断一个位置是否有值。只有当一个数组成员严格等于`undefined`，默认值才会生效*\n默认值可以引用解构赋值的其他变量，但该变量必须已经声明。\n```\nlet [a = 1, b = a] = [];     // a=1; b=1\nlet [a = 1, b = a] = [2];    // a=2; b=2\nlet [a = 1, b = a] = [1, 2]; // a=1; b=2\nlet [a = b, b = 1] = [];     // ReferenceError: b is not defined\n```\n如果解构的源不是数组，就会报错\n```\nlet [foo] = 1;\nlet [foo] = false;\nlet [foo] = NaN;\nlet [foo] = undefined;\nlet [foo] = null;\nlet [foo] = {};\n```\n#### 对象解构赋值\n对象解构赋值同样遵循左右互相匹配的规则，类似数组一样有嵌套，默认值等，但要注意的是**变量名称需要和对象中的属性值要对应，因为数组的位置相对应来说是有序的，而对象中是无序的，只能通过属性来作为位置查找。**如果要使用其它的变量名称，可以使用`:`重新指定变量名称，注意此时引用地址已被新变量接收,`:`左边的变量就没有地址了，再访问的话是空的，是真的输出为空的字符，在下面示例代码中有对应的写法：\n```\n//基本\n{\n  let {a,b} = {a:1,b:2}\n  console.log(a,b);\n  let {name:newName} = {name:'tony'}\n  console.log(name)//''\n  console.log(newName)//tony\n}\n//默认值\n{\n  let {x = 3} = {};\n  let {a,b = 2}={a:1};\n}\n//嵌套\n{\n  const obj = {\n    name:{\n      chinese_name:{\n        first_name:'Chen',\n        last_name:'chuhai'\n      },\n      english_name:{\n        first_name:'Chen',\n        last_name:'tony'\n      }\n    }\n  };\n  let {name,name:{chinese_name},name:{chinese_name:{last_name:my_name}}} = obj;\n  console.log(name);//{chinese_name: {...},english_name: {...}}\n  console.log(chinese_name);//{first_name: \"Chen\",last_name: \"chuhai\"}\n  console.log(my_name)//chuhai\n}\n```\n和数组一样，对象解构也有嵌套，只是这个嵌套容易让人犯晕，别怕，回顾着之前讲的，一层层剥析。\n先看解构赋值的左边，前面说了叫做解构的目标，第一个为name变量，这个很简单了，这个就对应着右边解构源叫做name的属性值，然后是第二个解构目标，根据左右匹配的规则，可以得出chinese_name就是右边解构源name属性值对象中chinese_name的属性值，最后第三个，last_name就是对应结构源上\"chuhai\"这个值了，只是用`:`重新指定了变量的名称为my_name。\n结构目标最后只有一个，即得出最后的变量只有一个，第二次和第三次过程中分别出现的name和chinese_name，只是得到解构目标过程中为了和解构源相匹配而出现的，这样说应该就能解决大部分人对在解构目标出现的多个变量的迷惑了（可能只是我刚一接触时有这种迷惑），那些不是最终的变量，而是为了**匹配解构源对应位置的**\n\n解构赋值也并不是一定需要声明变量来赋值的，还可以通过下面的方式进行赋值\n```\nlet obj = {};\nlet arr = [];\n({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });\nobj // {prop:123}\narr // [true]\n```\n代码很容易看明白，抛出一个注意点，解构赋值的表达式用了一个括号，为什么呢？\n因为不那么写会报错。解构赋值用的变量在之前有声明过，而`{}`恰好会被作为代码块理解,这样上下文出现两个相同名称的变量解析时就会报错，放在一个圆括号里面，就可以正确执行。详细原因请大家看[大神阮一峰es6入门--圆括号问题](https://es6.ruanyifeng.com/#docs/destructuring#%E5%9C%86%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98)\n对象解构赋值和数组差不多，有没有独特一点的？\n有的，对象的解构赋值还可以拿到继承的属性，然后数组是特殊的对象，其实也能用对象解构的方式来解构数组。上代码\n>//继承\nconst obj1 = {};\nconst obj2 = { foo: 'bar' };\nObject.setPrototypeOf(obj1, obj2);\nconst { foo } = obj1;// \"bar\"\n//数组解构\nlet arr = [1, 2, 3];\nlet {0 : first, [arr.length - 1] : last} = arr;\nfirst // 1\nlast // 3\n\n#### 字符串的解构赋值\n后面的几种解构赋值基本上也是从对象解构或者数组解构延伸出来的，字符串可以看成一个被分割为数组的对象，所以，可以这么用\n{\n  //作为数组\n  let [a,b,c,d] = 'tony';\n  console.log(a,b,c,d);//t o n y\n  //作为对象解构还能这么用\n  let {length} = 'tony';\n  console.log(length);//4\n}\n\n#### 数值和布尔解构赋值\n解构赋值按照左右匹配规则来说，只要解构的源有数值，有结构，那么都可以进行解构，关键是看以什么解构规则进行解构，除去上面的数组对象字符串，其它的只要能转成对象，有结构，有数值，就可以进行解构，像`undefined`和`null`没值没结构的，就无法进行解构了，而布尔和数值可以。\n{\n  //转为对象后继承了字符对象的toString方法\n  let {toString: s} = 123;\n  s === Number.prototype.toString // true\n  let {toString: s} = true;\n  s === Boolean.prototype.toString // true\n}\n#### 函数参数解构赋值\n这部分函数解构赋值并不是简单的这样\n```\n{\n  function f(){\n    return [1,2]\n  }\n  let a,b;\n  [a,b]=f();\n  console.log(a,b);\n}\n```\n这样实际是拿函数的执行结果来进行解构赋值太小儿科，我也曾想过为什么不能是`{} = f`这样的解构赋值，方法里面虽然有结构有内容，但是，谁能告诉怎么个一一对应法，这不可能，所以，只能拿方法的传参讲讲了。\n```\n{\n  function add([a, b]){\n    return a + b;\n  }\n  console.log(add([1, 2])) // 3\n  console.log([[1, 2], [3, 4]].map(([a, b]) => a + b)) //[3,7];\n}\n```\n在传参的过程中进行解构赋值，原理和前面讲的解构赋值是一样的。\n\n至此结构赋值的类型都说完了，回到最初说明这一运算的用途，除了交换变量，还有其它的用途，在此一一列举：\n至此结构赋值的类型都说完了，回到最初说明这一运算的用途，除了交换变量，还有其它的用途，在此一一列举：\n- 交换变量\n- 处理函数返回值(见上述函数参数解构赋值的第一段代码)\n- 处理函数传参(还是见上述函数参数解构赋值的代码)\n- 处理JSON数据\n- 函数参数的默认值\n- 遍历 Map 结构\n- 引入模块的指定方法\n```\n  import { loginHtml, loginResultPage, userWxBinding, consolidatedAccountContent} from '../../html/login';\n```\n以上为解构赋值的笔记内容，如有补充和需探讨的，欢迎留言评论~","slug":"ES项目学习笔记（三）赋值操作更简便-解构赋值","published":1,"updated":"2019-12-06T14:45:44.973Z","_id":"ck34bmw8e0002ycrwzhp1e1m6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>用一个经常遇到的问题来说明这一赋值的好处之一，<strong>对两个变量的值进行替换</strong>，通常我们得另外声明一个变量来作为两个变量交换的媒介，而现在如下代码就可以解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  let a=1;</span><br><span class=\"line\">  let b=2;</span><br><span class=\"line\">  [a,b]=[b,a];</span><br><span class=\"line\">  console.log(a,b);  //2,1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解构赋值上述的用法是对<strong>数组的解构赋值</strong>，总的来说结构赋值大致可以分为<strong>数组解构赋值</strong>，<strong>对象解构赋值</strong>，<strong>字符解构赋值</strong>，<strong>数值和布尔解构赋值</strong>，<strong>函数参数解构赋值</strong>。</p>\n<p>无论何种解构赋值，解构赋值表达式的左边部分，即<strong>解构的目标</strong>，而右边的值，即左边<strong>解构的源</strong>，都遵循一个左右互相匹配的规则，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p>\n<h4 id=\"数组解构赋值\"><a href=\"#数组解构赋值\" class=\"headerlink\" title=\"数组解构赋值\"></a>数组解构赋值</h4><p>上述的代码就是数组解构赋值的<strong>基本用法</strong>。以下是数组解构赋值的其它使用方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//嵌套</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  let [a, [[b], c]] = [1, [[2], 3]];</span><br><span class=\"line\">  console.log(a,b,c); //1,2,3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//可忽略</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  let [a, , b] = [1, 2, 3];</span><br><span class=\"line\">  console.log(a,b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//剩余运算符</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  let a,b,rest;</span><br><span class=\"line\">  [a,b,...rest] = [1,2,3,4,5,6];</span><br><span class=\"line\">  console.log(a,b,rest); //1,2,[4,5,6]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//不完全解构</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tlet [a,b] = [1,2,3];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述的变量全都可以成功赋值，也就是成功解构，但也有无法解构成功的，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [a] = [];</span><br><span class=\"line\">let [b, d,...c] = [1];</span><br><span class=\"line\">console.log(a);  //undefined</span><br><span class=\"line\">console.log(b,d,c); //1,undefined,[]</span><br></pre></td></tr></table></figure>\n\n<p>当解构目标在解构的源对应位置找不到值,则无法成功解构,变量的值就会变成<code>undefined</code>,…剩余运算符的变量为<code>[]</code>.<br>在实际开发场景中返回的值可能有多种情况,可能你想要的值在某个位置确实没有,那么还可以使用<strong>默认值</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [a,b = 1] = [1];</span><br><span class=\"line\">console.log(a,b); //1,1</span><br><span class=\"line\">let [c = 1,d = 2] = [undefined,null];</span><br><span class=\"line\">console.log(c,d); //1,null</span><br></pre></td></tr></table></figure>\n\n<p><em>ES6 内部使用严格相等运算符（===），判断一个位置是否有值。只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效</em><br>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [a = 1, b = a] = [];     // a=1; b=1</span><br><span class=\"line\">let [a = 1, b = a] = [2];    // a=2; b=2</span><br><span class=\"line\">let [a = 1, b = a] = [1, 2]; // a=1; b=2</span><br><span class=\"line\">let [a = b, b = 1] = [];     // ReferenceError: b is not defined</span><br></pre></td></tr></table></figure>\n\n<p>如果解构的源不是数组，就会报错</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [foo] = 1;</span><br><span class=\"line\">let [foo] = false;</span><br><span class=\"line\">let [foo] = NaN;</span><br><span class=\"line\">let [foo] = undefined;</span><br><span class=\"line\">let [foo] = null;</span><br><span class=\"line\">let [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"对象解构赋值\"><a href=\"#对象解构赋值\" class=\"headerlink\" title=\"对象解构赋值\"></a>对象解构赋值</h4><p>对象解构赋值同样遵循左右互相匹配的规则，类似数组一样有嵌套，默认值等，但要注意的是<strong>变量名称需要和对象中的属性值要对应，因为数组的位置相对应来说是有序的，而对象中是无序的，只能通过属性来作为位置查找。</strong>如果要使用其它的变量名称，可以使用<code>:</code>重新指定变量名称，注意此时引用地址已被新变量接收,<code>:</code>左边的变量就没有地址了，再访问的话是空的，是真的输出为空的字符，在下面示例代码中有对应的写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//基本</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  let &#123;a,b&#125; = &#123;a:1,b:2&#125;</span><br><span class=\"line\">  console.log(a,b);</span><br><span class=\"line\">  let &#123;name:newName&#125; = &#123;name:&apos;tony&apos;&#125;</span><br><span class=\"line\">  console.log(name)//&apos;&apos;</span><br><span class=\"line\">  console.log(newName)//tony</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//默认值</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  let &#123;x = 3&#125; = &#123;&#125;;</span><br><span class=\"line\">  let &#123;a,b = 2&#125;=&#123;a:1&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//嵌套</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  const obj = &#123;</span><br><span class=\"line\">    name:&#123;</span><br><span class=\"line\">      chinese_name:&#123;</span><br><span class=\"line\">        first_name:&apos;Chen&apos;,</span><br><span class=\"line\">        last_name:&apos;chuhai&apos;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      english_name:&#123;</span><br><span class=\"line\">        first_name:&apos;Chen&apos;,</span><br><span class=\"line\">        last_name:&apos;tony&apos;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  let &#123;name,name:&#123;chinese_name&#125;,name:&#123;chinese_name:&#123;last_name:my_name&#125;&#125;&#125; = obj;</span><br><span class=\"line\">  console.log(name);//&#123;chinese_name: &#123;...&#125;,english_name: &#123;...&#125;&#125;</span><br><span class=\"line\">  console.log(chinese_name);//&#123;first_name: &quot;Chen&quot;,last_name: &quot;chuhai&quot;&#125;</span><br><span class=\"line\">  console.log(my_name)//chuhai</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和数组一样，对象解构也有嵌套，只是这个嵌套容易让人犯晕，别怕，回顾着之前讲的，一层层剥析。<br>先看解构赋值的左边，前面说了叫做解构的目标，第一个为name变量，这个很简单了，这个就对应着右边解构源叫做name的属性值，然后是第二个解构目标，根据左右匹配的规则，可以得出chinese_name就是右边解构源name属性值对象中chinese_name的属性值，最后第三个，last_name就是对应结构源上”chuhai”这个值了，只是用<code>:</code>重新指定了变量的名称为my_name。<br>结构目标最后只有一个，即得出最后的变量只有一个，第二次和第三次过程中分别出现的name和chinese_name，只是得到解构目标过程中为了和解构源相匹配而出现的，这样说应该就能解决大部分人对在解构目标出现的多个变量的迷惑了（可能只是我刚一接触时有这种迷惑），那些不是最终的变量，而是为了<strong>匹配解构源对应位置的</strong></p>\n<p>解构赋值也并不是一定需要声明变量来赋值的，还可以通过下面的方式进行赋值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;&#125;;</span><br><span class=\"line\">let arr = [];</span><br><span class=\"line\">(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);</span><br><span class=\"line\">obj // &#123;prop:123&#125;</span><br><span class=\"line\">arr // [true]</span><br></pre></td></tr></table></figure>\n\n<p>代码很容易看明白，抛出一个注意点，解构赋值的表达式用了一个括号，为什么呢？<br>因为不那么写会报错。解构赋值用的变量在之前有声明过，而<code>{}</code>恰好会被作为代码块理解,这样上下文出现两个相同名称的变量解析时就会报错，放在一个圆括号里面，就可以正确执行。详细原因请大家看<a href=\"https://es6.ruanyifeng.com/#docs/destructuring#%E5%9C%86%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98\" target=\"_blank\" rel=\"noopener\">大神阮一峰es6入门–圆括号问题</a><br>对象解构赋值和数组差不多，有没有独特一点的？<br>有的，对象的解构赋值还可以拿到继承的属性，然后数组是特殊的对象，其实也能用对象解构的方式来解构数组。上代码</p>\n<blockquote>\n<p>//继承<br>const obj1 = {};<br>const obj2 = { foo: ‘bar’ };<br>Object.setPrototypeOf(obj1, obj2);<br>const { foo } = obj1;// “bar”<br>//数组解构<br>let arr = [1, 2, 3];<br>let {0 : first, [arr.length - 1] : last} = arr;<br>first // 1<br>last // 3</p>\n</blockquote>\n<h4 id=\"字符串的解构赋值\"><a href=\"#字符串的解构赋值\" class=\"headerlink\" title=\"字符串的解构赋值\"></a>字符串的解构赋值</h4><p>后面的几种解构赋值基本上也是从对象解构或者数组解构延伸出来的，字符串可以看成一个被分割为数组的对象，所以，可以这么用<br>{<br>  //作为数组<br>  let [a,b,c,d] = ‘tony’;<br>  console.log(a,b,c,d);//t o n y<br>  //作为对象解构还能这么用<br>  let {length} = ‘tony’;<br>  console.log(length);//4<br>}</p>\n<h4 id=\"数值和布尔解构赋值\"><a href=\"#数值和布尔解构赋值\" class=\"headerlink\" title=\"数值和布尔解构赋值\"></a>数值和布尔解构赋值</h4><p>解构赋值按照左右匹配规则来说，只要解构的源有数值，有结构，那么都可以进行解构，关键是看以什么解构规则进行解构，除去上面的数组对象字符串，其它的只要能转成对象，有结构，有数值，就可以进行解构，像<code>undefined</code>和<code>null</code>没值没结构的，就无法进行解构了，而布尔和数值可以。<br>{<br>  //转为对象后继承了字符对象的toString方法<br>  let {toString: s} = 123;<br>  s === Number.prototype.toString // true<br>  let {toString: s} = true;<br>  s === Boolean.prototype.toString // true<br>}</p>\n<h4 id=\"函数参数解构赋值\"><a href=\"#函数参数解构赋值\" class=\"headerlink\" title=\"函数参数解构赋值\"></a>函数参数解构赋值</h4><p>这部分函数解构赋值并不是简单的这样</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  function f()&#123;</span><br><span class=\"line\">    return [1,2]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let a,b;</span><br><span class=\"line\">  [a,b]=f();</span><br><span class=\"line\">  console.log(a,b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样实际是拿函数的执行结果来进行解构赋值太小儿科，我也曾想过为什么不能是<code>{} = f</code>这样的解构赋值，方法里面虽然有结构有内容，但是，谁能告诉怎么个一一对应法，这不可能，所以，只能拿方法的传参讲讲了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  function add([a, b])&#123;</span><br><span class=\"line\">    return a + b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(add([1, 2])) // 3</span><br><span class=\"line\">  console.log([[1, 2], [3, 4]].map(([a, b]) =&gt; a + b)) //[3,7];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在传参的过程中进行解构赋值，原理和前面讲的解构赋值是一样的。</p>\n<p>至此结构赋值的类型都说完了，回到最初说明这一运算的用途，除了交换变量，还有其它的用途，在此一一列举：<br>至此结构赋值的类型都说完了，回到最初说明这一运算的用途，除了交换变量，还有其它的用途，在此一一列举：</p>\n<ul>\n<li>交换变量</li>\n<li>处理函数返回值(见上述函数参数解构赋值的第一段代码)</li>\n<li>处理函数传参(还是见上述函数参数解构赋值的代码)</li>\n<li>处理JSON数据</li>\n<li>函数参数的默认值</li>\n<li>遍历 Map 结构</li>\n<li>引入模块的指定方法<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; loginHtml, loginResultPage, userWxBinding, consolidatedAccountContent&#125; from &apos;../../html/login&apos;;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>以上为解构赋值的笔记内容，如有补充和需探讨的，欢迎留言评论~</p>\n","site":{"data":{}},"excerpt":"","more":"<p>用一个经常遇到的问题来说明这一赋值的好处之一，<strong>对两个变量的值进行替换</strong>，通常我们得另外声明一个变量来作为两个变量交换的媒介，而现在如下代码就可以解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  let a=1;</span><br><span class=\"line\">  let b=2;</span><br><span class=\"line\">  [a,b]=[b,a];</span><br><span class=\"line\">  console.log(a,b);  //2,1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解构赋值上述的用法是对<strong>数组的解构赋值</strong>，总的来说结构赋值大致可以分为<strong>数组解构赋值</strong>，<strong>对象解构赋值</strong>，<strong>字符解构赋值</strong>，<strong>数值和布尔解构赋值</strong>，<strong>函数参数解构赋值</strong>。</p>\n<p>无论何种解构赋值，解构赋值表达式的左边部分，即<strong>解构的目标</strong>，而右边的值，即左边<strong>解构的源</strong>，都遵循一个左右互相匹配的规则，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p>\n<h4 id=\"数组解构赋值\"><a href=\"#数组解构赋值\" class=\"headerlink\" title=\"数组解构赋值\"></a>数组解构赋值</h4><p>上述的代码就是数组解构赋值的<strong>基本用法</strong>。以下是数组解构赋值的其它使用方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//嵌套</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  let [a, [[b], c]] = [1, [[2], 3]];</span><br><span class=\"line\">  console.log(a,b,c); //1,2,3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//可忽略</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  let [a, , b] = [1, 2, 3];</span><br><span class=\"line\">  console.log(a,b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//剩余运算符</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  let a,b,rest;</span><br><span class=\"line\">  [a,b,...rest] = [1,2,3,4,5,6];</span><br><span class=\"line\">  console.log(a,b,rest); //1,2,[4,5,6]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//不完全解构</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tlet [a,b] = [1,2,3];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述的变量全都可以成功赋值，也就是成功解构，但也有无法解构成功的，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [a] = [];</span><br><span class=\"line\">let [b, d,...c] = [1];</span><br><span class=\"line\">console.log(a);  //undefined</span><br><span class=\"line\">console.log(b,d,c); //1,undefined,[]</span><br></pre></td></tr></table></figure>\n\n<p>当解构目标在解构的源对应位置找不到值,则无法成功解构,变量的值就会变成<code>undefined</code>,…剩余运算符的变量为<code>[]</code>.<br>在实际开发场景中返回的值可能有多种情况,可能你想要的值在某个位置确实没有,那么还可以使用<strong>默认值</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [a,b = 1] = [1];</span><br><span class=\"line\">console.log(a,b); //1,1</span><br><span class=\"line\">let [c = 1,d = 2] = [undefined,null];</span><br><span class=\"line\">console.log(c,d); //1,null</span><br></pre></td></tr></table></figure>\n\n<p><em>ES6 内部使用严格相等运算符（===），判断一个位置是否有值。只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效</em><br>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [a = 1, b = a] = [];     // a=1; b=1</span><br><span class=\"line\">let [a = 1, b = a] = [2];    // a=2; b=2</span><br><span class=\"line\">let [a = 1, b = a] = [1, 2]; // a=1; b=2</span><br><span class=\"line\">let [a = b, b = 1] = [];     // ReferenceError: b is not defined</span><br></pre></td></tr></table></figure>\n\n<p>如果解构的源不是数组，就会报错</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [foo] = 1;</span><br><span class=\"line\">let [foo] = false;</span><br><span class=\"line\">let [foo] = NaN;</span><br><span class=\"line\">let [foo] = undefined;</span><br><span class=\"line\">let [foo] = null;</span><br><span class=\"line\">let [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"对象解构赋值\"><a href=\"#对象解构赋值\" class=\"headerlink\" title=\"对象解构赋值\"></a>对象解构赋值</h4><p>对象解构赋值同样遵循左右互相匹配的规则，类似数组一样有嵌套，默认值等，但要注意的是<strong>变量名称需要和对象中的属性值要对应，因为数组的位置相对应来说是有序的，而对象中是无序的，只能通过属性来作为位置查找。</strong>如果要使用其它的变量名称，可以使用<code>:</code>重新指定变量名称，注意此时引用地址已被新变量接收,<code>:</code>左边的变量就没有地址了，再访问的话是空的，是真的输出为空的字符，在下面示例代码中有对应的写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//基本</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  let &#123;a,b&#125; = &#123;a:1,b:2&#125;</span><br><span class=\"line\">  console.log(a,b);</span><br><span class=\"line\">  let &#123;name:newName&#125; = &#123;name:&apos;tony&apos;&#125;</span><br><span class=\"line\">  console.log(name)//&apos;&apos;</span><br><span class=\"line\">  console.log(newName)//tony</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//默认值</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  let &#123;x = 3&#125; = &#123;&#125;;</span><br><span class=\"line\">  let &#123;a,b = 2&#125;=&#123;a:1&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//嵌套</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  const obj = &#123;</span><br><span class=\"line\">    name:&#123;</span><br><span class=\"line\">      chinese_name:&#123;</span><br><span class=\"line\">        first_name:&apos;Chen&apos;,</span><br><span class=\"line\">        last_name:&apos;chuhai&apos;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      english_name:&#123;</span><br><span class=\"line\">        first_name:&apos;Chen&apos;,</span><br><span class=\"line\">        last_name:&apos;tony&apos;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  let &#123;name,name:&#123;chinese_name&#125;,name:&#123;chinese_name:&#123;last_name:my_name&#125;&#125;&#125; = obj;</span><br><span class=\"line\">  console.log(name);//&#123;chinese_name: &#123;...&#125;,english_name: &#123;...&#125;&#125;</span><br><span class=\"line\">  console.log(chinese_name);//&#123;first_name: &quot;Chen&quot;,last_name: &quot;chuhai&quot;&#125;</span><br><span class=\"line\">  console.log(my_name)//chuhai</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和数组一样，对象解构也有嵌套，只是这个嵌套容易让人犯晕，别怕，回顾着之前讲的，一层层剥析。<br>先看解构赋值的左边，前面说了叫做解构的目标，第一个为name变量，这个很简单了，这个就对应着右边解构源叫做name的属性值，然后是第二个解构目标，根据左右匹配的规则，可以得出chinese_name就是右边解构源name属性值对象中chinese_name的属性值，最后第三个，last_name就是对应结构源上”chuhai”这个值了，只是用<code>:</code>重新指定了变量的名称为my_name。<br>结构目标最后只有一个，即得出最后的变量只有一个，第二次和第三次过程中分别出现的name和chinese_name，只是得到解构目标过程中为了和解构源相匹配而出现的，这样说应该就能解决大部分人对在解构目标出现的多个变量的迷惑了（可能只是我刚一接触时有这种迷惑），那些不是最终的变量，而是为了<strong>匹配解构源对应位置的</strong></p>\n<p>解构赋值也并不是一定需要声明变量来赋值的，还可以通过下面的方式进行赋值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;&#125;;</span><br><span class=\"line\">let arr = [];</span><br><span class=\"line\">(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);</span><br><span class=\"line\">obj // &#123;prop:123&#125;</span><br><span class=\"line\">arr // [true]</span><br></pre></td></tr></table></figure>\n\n<p>代码很容易看明白，抛出一个注意点，解构赋值的表达式用了一个括号，为什么呢？<br>因为不那么写会报错。解构赋值用的变量在之前有声明过，而<code>{}</code>恰好会被作为代码块理解,这样上下文出现两个相同名称的变量解析时就会报错，放在一个圆括号里面，就可以正确执行。详细原因请大家看<a href=\"https://es6.ruanyifeng.com/#docs/destructuring#%E5%9C%86%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98\" target=\"_blank\" rel=\"noopener\">大神阮一峰es6入门–圆括号问题</a><br>对象解构赋值和数组差不多，有没有独特一点的？<br>有的，对象的解构赋值还可以拿到继承的属性，然后数组是特殊的对象，其实也能用对象解构的方式来解构数组。上代码</p>\n<blockquote>\n<p>//继承<br>const obj1 = {};<br>const obj2 = { foo: ‘bar’ };<br>Object.setPrototypeOf(obj1, obj2);<br>const { foo } = obj1;// “bar”<br>//数组解构<br>let arr = [1, 2, 3];<br>let {0 : first, [arr.length - 1] : last} = arr;<br>first // 1<br>last // 3</p>\n</blockquote>\n<h4 id=\"字符串的解构赋值\"><a href=\"#字符串的解构赋值\" class=\"headerlink\" title=\"字符串的解构赋值\"></a>字符串的解构赋值</h4><p>后面的几种解构赋值基本上也是从对象解构或者数组解构延伸出来的，字符串可以看成一个被分割为数组的对象，所以，可以这么用<br>{<br>  //作为数组<br>  let [a,b,c,d] = ‘tony’;<br>  console.log(a,b,c,d);//t o n y<br>  //作为对象解构还能这么用<br>  let {length} = ‘tony’;<br>  console.log(length);//4<br>}</p>\n<h4 id=\"数值和布尔解构赋值\"><a href=\"#数值和布尔解构赋值\" class=\"headerlink\" title=\"数值和布尔解构赋值\"></a>数值和布尔解构赋值</h4><p>解构赋值按照左右匹配规则来说，只要解构的源有数值，有结构，那么都可以进行解构，关键是看以什么解构规则进行解构，除去上面的数组对象字符串，其它的只要能转成对象，有结构，有数值，就可以进行解构，像<code>undefined</code>和<code>null</code>没值没结构的，就无法进行解构了，而布尔和数值可以。<br>{<br>  //转为对象后继承了字符对象的toString方法<br>  let {toString: s} = 123;<br>  s === Number.prototype.toString // true<br>  let {toString: s} = true;<br>  s === Boolean.prototype.toString // true<br>}</p>\n<h4 id=\"函数参数解构赋值\"><a href=\"#函数参数解构赋值\" class=\"headerlink\" title=\"函数参数解构赋值\"></a>函数参数解构赋值</h4><p>这部分函数解构赋值并不是简单的这样</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  function f()&#123;</span><br><span class=\"line\">    return [1,2]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let a,b;</span><br><span class=\"line\">  [a,b]=f();</span><br><span class=\"line\">  console.log(a,b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样实际是拿函数的执行结果来进行解构赋值太小儿科，我也曾想过为什么不能是<code>{} = f</code>这样的解构赋值，方法里面虽然有结构有内容，但是，谁能告诉怎么个一一对应法，这不可能，所以，只能拿方法的传参讲讲了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  function add([a, b])&#123;</span><br><span class=\"line\">    return a + b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(add([1, 2])) // 3</span><br><span class=\"line\">  console.log([[1, 2], [3, 4]].map(([a, b]) =&gt; a + b)) //[3,7];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在传参的过程中进行解构赋值，原理和前面讲的解构赋值是一样的。</p>\n<p>至此结构赋值的类型都说完了，回到最初说明这一运算的用途，除了交换变量，还有其它的用途，在此一一列举：<br>至此结构赋值的类型都说完了，回到最初说明这一运算的用途，除了交换变量，还有其它的用途，在此一一列举：</p>\n<ul>\n<li>交换变量</li>\n<li>处理函数返回值(见上述函数参数解构赋值的第一段代码)</li>\n<li>处理函数传参(还是见上述函数参数解构赋值的代码)</li>\n<li>处理JSON数据</li>\n<li>函数参数的默认值</li>\n<li>遍历 Map 结构</li>\n<li>引入模块的指定方法<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; loginHtml, loginResultPage, userWxBinding, consolidatedAccountContent&#125; from &apos;../../html/login&apos;;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>以上为解构赋值的笔记内容，如有补充和需探讨的，欢迎留言评论~</p>\n"},{"title":"建立hexo个人博客过程记录","date":"2019-09-19T08:40:58.000Z","_content":"偶然在网上逛的时候看到的,饶有兴趣的尝试了一下,各种问题.\n\n先说结论:\n\n   - 看到什么文章写工具的使用的,先到人家官方api看吧,照着官方文档做,出什么问题再看文章博客,别人博客说不定也只是搬运人家官方文档而已;\n\n   - 写博客文章,我真想不明白Markdown这种编辑文章的方式怎么流行起来的,word编辑器不好用么.也可能是我刚上手不熟悉,也许熟悉了会快很多,那再说;\n\n   - 用第三方工具构建个人的技术博客,如果只是记录需要,简书,csdn,等等平台可以快速的记录并发表文章,可以不用这么麻烦去搭建.如果是想要开放性的DIY自己的个人博客,选择这个第三方工具可能不是最优选,至少看它官方文档并不是很好用啊.如果有更好的,请推荐下.\n\n贴上官方链接:[https://hexo.io/zh-cn/docs/](https://hexo.io/zh-cn/docs/)\n\n按官方文档的操作你可以很轻松的在本地跑起来(windows系统).如果没有跑起来,你可以注意一下:\n![](/blog/images/5106777-240a8745b1e195f1.png)\n\n然后就遇到第一个问题,路径问题.\n我在github上的项目路径其实是在![](/blog/images/5106777-2a92ba6f32a3d3f9.png)\n\n如果我在看那个博客之前就看了官方文档就好了,就不会部署到github上面样式什么的都出不来.其实文档上面对url路径有进行温馨的说明\n![这个配置在根目录的_config.yml文件中修改](/blog/images/5106777-b79265113319f19c.png)\n\n很好,解决完了这个之前,还有一个问题,在github上面的部署问题\n![](/blog/images/5106777-920c509dfffadc21.png)\n\n![](/blog/images/5106777-87cfc19d337ca8d1.png)\n当然现在解决完了绿了,之前的报错类似的意思就是服务器时区之类的,应该是,一堆英文看不懂\n![](/blog/images/5106777-a10e999040e7762c.png)\n解决方法就是在项目下新增一个文件名为.nojekyll的空文件\n![](/blog/images/5106777-cf08e99288003e68.png)\n\n上面的问题解决完,按照文档的敲命令部署推送,点开链接,美得很,搭建完成.\n\n但是,一件事情要做成功,往往离不开坚持,博客搭建好了,还需要内容的填充,按照文档创建了一遍文章,累得半死,费劲心思写下文章,又是一阵心累,希望我能长久的坚持下去吧...\n\n","source":"_posts/建立hexo个人博客过程记录.md","raw":"---\ntitle: 建立hexo个人博客过程记录\ndate: 2019-09-19 16:40:58\ntags:\n---\n偶然在网上逛的时候看到的,饶有兴趣的尝试了一下,各种问题.\n\n先说结论:\n\n   - 看到什么文章写工具的使用的,先到人家官方api看吧,照着官方文档做,出什么问题再看文章博客,别人博客说不定也只是搬运人家官方文档而已;\n\n   - 写博客文章,我真想不明白Markdown这种编辑文章的方式怎么流行起来的,word编辑器不好用么.也可能是我刚上手不熟悉,也许熟悉了会快很多,那再说;\n\n   - 用第三方工具构建个人的技术博客,如果只是记录需要,简书,csdn,等等平台可以快速的记录并发表文章,可以不用这么麻烦去搭建.如果是想要开放性的DIY自己的个人博客,选择这个第三方工具可能不是最优选,至少看它官方文档并不是很好用啊.如果有更好的,请推荐下.\n\n贴上官方链接:[https://hexo.io/zh-cn/docs/](https://hexo.io/zh-cn/docs/)\n\n按官方文档的操作你可以很轻松的在本地跑起来(windows系统).如果没有跑起来,你可以注意一下:\n![](/blog/images/5106777-240a8745b1e195f1.png)\n\n然后就遇到第一个问题,路径问题.\n我在github上的项目路径其实是在![](/blog/images/5106777-2a92ba6f32a3d3f9.png)\n\n如果我在看那个博客之前就看了官方文档就好了,就不会部署到github上面样式什么的都出不来.其实文档上面对url路径有进行温馨的说明\n![这个配置在根目录的_config.yml文件中修改](/blog/images/5106777-b79265113319f19c.png)\n\n很好,解决完了这个之前,还有一个问题,在github上面的部署问题\n![](/blog/images/5106777-920c509dfffadc21.png)\n\n![](/blog/images/5106777-87cfc19d337ca8d1.png)\n当然现在解决完了绿了,之前的报错类似的意思就是服务器时区之类的,应该是,一堆英文看不懂\n![](/blog/images/5106777-a10e999040e7762c.png)\n解决方法就是在项目下新增一个文件名为.nojekyll的空文件\n![](/blog/images/5106777-cf08e99288003e68.png)\n\n上面的问题解决完,按照文档的敲命令部署推送,点开链接,美得很,搭建完成.\n\n但是,一件事情要做成功,往往离不开坚持,博客搭建好了,还需要内容的填充,按照文档创建了一遍文章,累得半死,费劲心思写下文章,又是一阵心累,希望我能长久的坚持下去吧...\n\n","slug":"建立hexo个人博客过程记录","published":1,"updated":"2019-09-19T09:16:36.980Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck34bmw8g0003ycrwsh5t4yo0","content":"<p>偶然在网上逛的时候看到的,饶有兴趣的尝试了一下,各种问题.</p>\n<p>先说结论:</p>\n<ul>\n<li><p>看到什么文章写工具的使用的,先到人家官方api看吧,照着官方文档做,出什么问题再看文章博客,别人博客说不定也只是搬运人家官方文档而已;</p>\n</li>\n<li><p>写博客文章,我真想不明白Markdown这种编辑文章的方式怎么流行起来的,word编辑器不好用么.也可能是我刚上手不熟悉,也许熟悉了会快很多,那再说;</p>\n</li>\n<li><p>用第三方工具构建个人的技术博客,如果只是记录需要,简书,csdn,等等平台可以快速的记录并发表文章,可以不用这么麻烦去搭建.如果是想要开放性的DIY自己的个人博客,选择这个第三方工具可能不是最优选,至少看它官方文档并不是很好用啊.如果有更好的,请推荐下.</p>\n</li>\n</ul>\n<p>贴上官方链接:<a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"noopener\">https://hexo.io/zh-cn/docs/</a></p>\n<p>按官方文档的操作你可以很轻松的在本地跑起来(windows系统).如果没有跑起来,你可以注意一下:<br><img src=\"/blog/images/5106777-240a8745b1e195f1.png\" alt></p>\n<p>然后就遇到第一个问题,路径问题.<br>我在github上的项目路径其实是在<img src=\"/blog/images/5106777-2a92ba6f32a3d3f9.png\" alt></p>\n<p>如果我在看那个博客之前就看了官方文档就好了,就不会部署到github上面样式什么的都出不来.其实文档上面对url路径有进行温馨的说明<br><img src=\"/blog/images/5106777-b79265113319f19c.png\" alt=\"这个配置在根目录的_config.yml文件中修改\"></p>\n<p>很好,解决完了这个之前,还有一个问题,在github上面的部署问题<br><img src=\"/blog/images/5106777-920c509dfffadc21.png\" alt></p>\n<p><img src=\"/blog/images/5106777-87cfc19d337ca8d1.png\" alt><br>当然现在解决完了绿了,之前的报错类似的意思就是服务器时区之类的,应该是,一堆英文看不懂<br><img src=\"/blog/images/5106777-a10e999040e7762c.png\" alt><br>解决方法就是在项目下新增一个文件名为.nojekyll的空文件<br><img src=\"/blog/images/5106777-cf08e99288003e68.png\" alt></p>\n<p>上面的问题解决完,按照文档的敲命令部署推送,点开链接,美得很,搭建完成.</p>\n<p>但是,一件事情要做成功,往往离不开坚持,博客搭建好了,还需要内容的填充,按照文档创建了一遍文章,累得半死,费劲心思写下文章,又是一阵心累,希望我能长久的坚持下去吧…</p>\n","site":{"data":{}},"excerpt":"","more":"<p>偶然在网上逛的时候看到的,饶有兴趣的尝试了一下,各种问题.</p>\n<p>先说结论:</p>\n<ul>\n<li><p>看到什么文章写工具的使用的,先到人家官方api看吧,照着官方文档做,出什么问题再看文章博客,别人博客说不定也只是搬运人家官方文档而已;</p>\n</li>\n<li><p>写博客文章,我真想不明白Markdown这种编辑文章的方式怎么流行起来的,word编辑器不好用么.也可能是我刚上手不熟悉,也许熟悉了会快很多,那再说;</p>\n</li>\n<li><p>用第三方工具构建个人的技术博客,如果只是记录需要,简书,csdn,等等平台可以快速的记录并发表文章,可以不用这么麻烦去搭建.如果是想要开放性的DIY自己的个人博客,选择这个第三方工具可能不是最优选,至少看它官方文档并不是很好用啊.如果有更好的,请推荐下.</p>\n</li>\n</ul>\n<p>贴上官方链接:<a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"noopener\">https://hexo.io/zh-cn/docs/</a></p>\n<p>按官方文档的操作你可以很轻松的在本地跑起来(windows系统).如果没有跑起来,你可以注意一下:<br><img src=\"/blog/images/5106777-240a8745b1e195f1.png\" alt></p>\n<p>然后就遇到第一个问题,路径问题.<br>我在github上的项目路径其实是在<img src=\"/blog/images/5106777-2a92ba6f32a3d3f9.png\" alt></p>\n<p>如果我在看那个博客之前就看了官方文档就好了,就不会部署到github上面样式什么的都出不来.其实文档上面对url路径有进行温馨的说明<br><img src=\"/blog/images/5106777-b79265113319f19c.png\" alt=\"这个配置在根目录的_config.yml文件中修改\"></p>\n<p>很好,解决完了这个之前,还有一个问题,在github上面的部署问题<br><img src=\"/blog/images/5106777-920c509dfffadc21.png\" alt></p>\n<p><img src=\"/blog/images/5106777-87cfc19d337ca8d1.png\" alt><br>当然现在解决完了绿了,之前的报错类似的意思就是服务器时区之类的,应该是,一堆英文看不懂<br><img src=\"/blog/images/5106777-a10e999040e7762c.png\" alt><br>解决方法就是在项目下新增一个文件名为.nojekyll的空文件<br><img src=\"/blog/images/5106777-cf08e99288003e68.png\" alt></p>\n<p>上面的问题解决完,按照文档的敲命令部署推送,点开链接,美得很,搭建完成.</p>\n<p>但是,一件事情要做成功,往往离不开坚持,博客搭建好了,还需要内容的填充,按照文档创建了一遍文章,累得半死,费劲心思写下文章,又是一阵心累,希望我能长久的坚持下去吧…</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}