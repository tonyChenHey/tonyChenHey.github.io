{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/5106777-240a8745b1e195f1.png","path":"images/5106777-240a8745b1e195f1.png","modified":1,"renderable":0},{"_id":"source/images/5106777-2a92ba6f32a3d3f9.png","path":"images/5106777-2a92ba6f32a3d3f9.png","modified":1,"renderable":0},{"_id":"source/images/5106777-87cfc19d337ca8d1.png","path":"images/5106777-87cfc19d337ca8d1.png","modified":1,"renderable":0},{"_id":"source/images/5106777-920c509dfffadc21.png","path":"images/5106777-920c509dfffadc21.png","modified":1,"renderable":0},{"_id":"source/images/5106777-a10e999040e7762c.png","path":"images/5106777-a10e999040e7762c.png","modified":1,"renderable":0},{"_id":"source/images/5106777-b79265113319f19c.png","path":"images/5106777-b79265113319f19c.png","modified":1,"renderable":0},{"_id":"source/images/5106777-cf08e99288003e68.png","path":"images/5106777-cf08e99288003e68.png","modified":1,"renderable":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/landscape/Gruntfile.js","hash":"412e30530784993c8997aa8b1319c669b83b91c2","modified":1568870268934},{"_id":"themes/landscape/LICENSE","hash":"82ce1e15ddeabeaaca60e2186b5a3ce42b1a9c49","modified":1568870268945},{"_id":"themes/landscape/README.md","hash":"67fedfb66304f103c412f6be110bf3c40c75d4ac","modified":1568870268954},{"_id":"themes/landscape/_config.yml","hash":"ce9d2939245209b8f5c5bbbdadc917d86057d032","modified":1568870268957},{"_id":"themes/landscape/package.json","hash":"6e567a9654e61eb3f548c75edef380c2e135c433","modified":1568870269335},{"_id":"source/_posts/ES6项目学习笔记（一）作用域-定义的补充完善.md","hash":"d2d3aae75d108ba1ac8541c8b46187b7cc704691","modified":1574064947234},{"_id":"source/_posts/ES6项目学习笔记（二）let和const-变量声明的扩展.md","hash":"cd490972862cb3dddb62f73a5b1ea6c535b2cf81","modified":1574064948461},{"_id":"source/_posts/ES项目学习笔记（三）赋值操作更简便-解构赋值.md","hash":"dc14245eebe982fa4c2404591e057e4da32dc00b","modified":1574075010645},{"_id":"source/_posts/建立hexo个人博客过程记录.md","hash":"52c9ca3c935c230026576987b9c57d14f4054a96","modified":1568884596980},{"_id":"source/images/5106777-240a8745b1e195f1.png","hash":"9cb662bbd2a1ef33197dd44b3d962056a406c566","modified":1568883155403},{"_id":"source/images/5106777-2a92ba6f32a3d3f9.png","hash":"cc7c97900a7d184dc01650352336fbb5d62f6e7d","modified":1568883159173},{"_id":"source/images/5106777-87cfc19d337ca8d1.png","hash":"e3c2bc13f9b6ff8275d6887233f0837a24a9639c","modified":1568883172113},{"_id":"source/images/5106777-920c509dfffadc21.png","hash":"0013a7bf8a277a72426d1cf4658077c3b69f508a","modified":1568883167224},{"_id":"source/images/5106777-a10e999040e7762c.png","hash":"ee42b4d7f54ca6d1a9c1eecd6003d057de610f43","modified":1568883188501},{"_id":"source/images/5106777-b79265113319f19c.png","hash":"7dd613485348cdaccc7791686c70ed26fd241b6f","modified":1568883163578},{"_id":"source/images/5106777-cf08e99288003e68.png","hash":"c2a97b06e65637a428b1685f26b04f0fbc8a060a","modified":1568883192300},{"_id":"themes/landscape/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1568870268975},{"_id":"themes/landscape/languages/fr.yml","hash":"8cb0fe4b6913b4d5b662cdd0108a923c90025f85","modified":1568870268985},{"_id":"themes/landscape/languages/ko.yml","hash":"11330316e3c1262474a2b496e40dbc29f93fe01b","modified":1568870269003},{"_id":"themes/landscape/languages/ja.yml","hash":"3e2fedca096678c0c234ebffa4637828979296fa","modified":1568870268996},{"_id":"themes/landscape/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1568870269012},{"_id":"themes/landscape/languages/de.yml","hash":"d45cea36c5c83d7d09afcd1c26fff4a4c513c25b","modified":1568870268964},{"_id":"themes/landscape/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1568870269020},{"_id":"themes/landscape/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1568870269037},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1568870269046},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1568870269054},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1568870269277},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1568870269285},{"_id":"themes/landscape/layout/layout.ejs","hash":"5d86bc48b0f1bdce9a2bb548c2f8e7a4f50d499a","modified":1568870269302},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1568870269312},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1568870269321},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1568870269329},{"_id":"themes/landscape/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1568870269353},{"_id":"themes/landscape/languages/pt.yml","hash":"ae2c61b30e638f74f1a42c9ce39ac08d063b30f5","modified":1568870269028},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1568870269294},{"_id":"themes/landscape/languages/es.yml","hash":"e3b4937da4cd2d0393b8a0ba310e70fc605cc431","modified":1568870268982},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"5062c723721d8497eebad372f57092ade45041f4","modified":1568870269079},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"017c412bd3d60d22e493f02918e436a32d96bb84","modified":1568870269090},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"23fa55f719850aaabbc9439ffaae78542b21cf00","modified":1568889384650},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"5cf2b8a1148e6f8c4bd9ca9e3b84c7e5a59d56bc","modified":1568870269099},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"6faefe07f3d64e21c7743276e0f55ee1544f9d86","modified":1568870269107},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"ace3000bd3e01d03041d5be24f7640b6c003a5b5","modified":1568870269113},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1568870269121},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"a36cec48782782bac92622f369c750e5c7396510","modified":1568870269132},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"cf755454675d13a0813a922b575c06b6b74ab9fd","modified":1568870269141},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"347cf1befd2ea637c24bd5901929d8e36e359e75","modified":1568870269147},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"c70869569749a8f48cce202fa57926c06b55fdab","modified":1568870269217},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"0fe1e52c291c9499bd05b966e0b9aac5be351c58","modified":1568870269230},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"6017c54a8c3c8ff8db491cfbea3100c139da75d6","modified":1568870269258},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"16800f85ffb036d2644a26e02facd61acb3706e9","modified":1568870269247},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"7259c179aa0c41c02e467ad892292e90430aaabc","modified":1568870269267},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"866790acc13fed44b7ef74c3e19c300a3d6180d8","modified":1568870269241},{"_id":"themes/landscape/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1568870269366},{"_id":"themes/landscape/source/css/style.styl","hash":"4a3e64ee8dad5834860c30b4176882eff628ca6b","modified":1568870269582},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1568870269597},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1568870269605},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1568870269631},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1568870269622},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1568870269641},{"_id":"themes/landscape/source/css/_variables.styl","hash":"57bb02270eef16b4823a64ba663ccf2f247f34e5","modified":1568870269497},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1568870269709},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1568870269718},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1568870269727},{"_id":"themes/landscape/source/js/script.js","hash":"c0d368681c687258b628bacc84cc30d353de6d47","modified":1568870269744},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1568870269614},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1568870269162},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"cbb3819ce512bd24db8bad41b8617d46eba82fdc","modified":1568870269193},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1568870269201},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1568870269183},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1568870269209},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1568870269173},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"9e574d8eb1a5285ec3b4346607414770d2f7e0ff","modified":1568870269378},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1568870269415},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"2834870661e490775f9154d71638bfdc72e640a6","modified":1568870269398},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"ac19f1621305ca9f6a7b74acd211a4c0d88690bd","modified":1568870269423},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"1fb15f13ba70d5b954f62920c6b63d26e2fb2985","modified":1568870269441},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"4132e25ba9680c4b911a01abc75f501cda3fa4f1","modified":1568870269450},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"8d971a00e644a600179b04815688d188f094012e","modified":1568870269459},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1568870269477},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1568870269485},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"680c7b809b62cd3ad294e822793fbd0b1a32cc33","modified":1568870269433},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"e291bc8c5f0c21080baa549d5d9ef2f39a871ea7","modified":1568870269389},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"6f7aa810f296d6a1a4486637b5a853d35a198938","modified":1568870269406},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1568870269664},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1568870269682},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1568870269652},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1568870269673},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1568870269690},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1568870269514},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1568870269700},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1568870269521},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1568870269553},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1568870269542},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1568870269570},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1568870269532},{"_id":"public/2019/09/19/建立hexo个人博客过程记录/index.html","hash":"65ede3622f512f729181f1bc364d8f90cb6c32a4","modified":1574075038158},{"_id":"public/archives/index.html","hash":"e653192e156ed5e850f5c2a039b00f8940f7c9c4","modified":1574075038158},{"_id":"public/archives/2019/index.html","hash":"97d47253f1380a51dbf0e19b1ccd0359d95a62e7","modified":1574075038226},{"_id":"public/archives/2019/09/index.html","hash":"cf967183d1d44ffc26783c0ab2d25f8b6a659e93","modified":1574075038227},{"_id":"public/2019/11/18/ES项目学习笔记（三）赋值操作更简便-解构赋值/index.html","hash":"2d9960336699616f3219cac0fea17baf49c42ea2","modified":1574075038235},{"_id":"public/2019/11/18/ES6项目学习笔记（二）let和const-变量声明的扩展/index.html","hash":"a984f479a2cecc069456d024e6d40a57802bc71f","modified":1574075038236},{"_id":"public/2019/11/18/ES6项目学习笔记（一）作用域-定义的补充完善/index.html","hash":"d9adbf4c3ad8d166f66c2a5556a6efe4be107d9c","modified":1574075038236},{"_id":"public/archives/2019/11/index.html","hash":"6cf16bb9c011b38a5c7e8d4eb364a9d4b31560c2","modified":1574075038236},{"_id":"public/index.html","hash":"1dd2c8f171a1c4f58fda3addb4d3bdd8440a432b","modified":1574075038236},{"_id":"public/images/5106777-2a92ba6f32a3d3f9.png","hash":"cc7c97900a7d184dc01650352336fbb5d62f6e7d","modified":1574075038240},{"_id":"public/images/5106777-240a8745b1e195f1.png","hash":"9cb662bbd2a1ef33197dd44b3d962056a406c566","modified":1574075038240},{"_id":"public/images/5106777-87cfc19d337ca8d1.png","hash":"e3c2bc13f9b6ff8275d6887233f0837a24a9639c","modified":1574075038240},{"_id":"public/images/5106777-a10e999040e7762c.png","hash":"ee42b4d7f54ca6d1a9c1eecd6003d057de610f43","modified":1574075038241},{"_id":"public/images/5106777-b79265113319f19c.png","hash":"7dd613485348cdaccc7791686c70ed26fd241b6f","modified":1574075038241},{"_id":"public/images/5106777-cf08e99288003e68.png","hash":"c2a97b06e65637a428b1685f26b04f0fbc8a060a","modified":1574075038241},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1574075038241},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1574075038241},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1574075038241},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1574075038241},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1574075038241},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1574075038241},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1574075038242},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1574075038242},{"_id":"public/images/5106777-920c509dfffadc21.png","hash":"0013a7bf8a277a72426d1cf4658077c3b69f508a","modified":1574075039157},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1574075039158},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1574075039160},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1574075039160},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1574075039165},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1574075039165},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1574075039165},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1574075039166},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1574075039166},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1574075039166},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1574075039166},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1574075039166},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1574075039166},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1574075039166},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1574075039186},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1574075039239}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"ES6项目学习笔记（一）作用域 定义的补充完善","date":"2019-11-18T08:13:20.000Z","_content":"作用域是什么？\n抱着这个疑问，咱们不妨先看看下面的一段代码\n```\nvar name = 'tony';\nfunction hello(age){\n\tconsole.log(name);\n\tconsole.log(age);\n\tconsole.log(fullName);\n}\nhello();\n//tony\n//undefined\n//fullName is not defined\n```\n![实际运行结果](https://upload-images.jianshu.io/upload_images/5106777-26d49a73643e41b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n如果不了解作用域的看到代码可能会和我一样疑惑，为什么fullname“no defined”而age是\"undefined\"，有什么区别，以及为啥是\"no defined\"？\n有了这样的疑问我们再来看看我们所看到的一些解释：\n![作用域解释1](https://upload-images.jianshu.io/upload_images/5106777-482ac5610c5afe2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![作用域解释2](https://upload-images.jianshu.io/upload_images/5106777-9fe6c719aba92a08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n从这个两个解释里面我们可以提取出来两个要点，**规则** **集合**\n\n规则其实不难理解，就如同我们人在社会中一样，受到各种规则限制，而在js中处处存在的变量，也同样受到一套规则所限，同样有“生老病死”（变量生命周期），同样有自己的“人生轨迹”（作用域链）。\n在js中变量所受的作用域规则主要有了 **全局作用域**，**局部作用域**，**块状作用域**，**动态作用域**，\n\n这些作用域在上面的代码就有体现，我们可以先从我们最容易看懂的name变量入手，变量name是在整个代码中的最外层的,即在**函数外**,**代码块``{}``外**(es6新增)的,这就是全局作用域.\n我们说作用域是变量在整个js代码中运行的规则，这时候name在全局作用域的规则下就是：**网页中所有脚本和函数均可使用**，\n![全局作用域声明的变量可以在函数内部修改](https://upload-images.jianshu.io/upload_images/5106777-b9b9a3344fec8a1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n我们再把这段代码修改一下，就可以通过对比加深对全局作用域的理解，同时知道什么是函数作用域了\n![全局作用域的变量和函数作用域的变量](https://upload-images.jianshu.io/upload_images/5106777-9fd270f73dd404b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n函数内部定义的变量age，**在函数内部定义**的，就是局部作用域，很明显，它的规则就是**只能在函数内部访问**，你看在其它函数内修改也改变不了内部27的事实。在修改age的这个函数内，涉及到了js的变量提升编译词法等（[看这里](https://www.runoob.com/js/js-hoisting.html)），你在函数外打印age这个变量是可以得到20的，这更加说明了作用域的存在，超出了作用域，即便名字相同，也是不同的变量。这也是由于不同作用域可访问的变量不同导致的，可以再看一眼作用域的解释：\n![作用域为可访问对象，变量，函数的集合](https://upload-images.jianshu.io/upload_images/5106777-2379c3518739236a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n在函数内部，存在的可访问变量有name，age，在函数内部查找不到name这个变量时，会找到上一层全局作用域中，而查找age时，在局部作用域中就找到了，所以不会再在全局作用域中进行查找。\n作为局部作用域定义的变量可以很好的受到保护，不在外部就被随意更改，但是比如年龄这个东西，总不能每年询问的时候总是那个岁数吧\n![局部作用域的变量每次访问都被重置](https://upload-images.jianshu.io/upload_images/5106777-5e7d373f0a1fc8c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n所以我们需要每次访问的时候让函数内部自己+1。类似这样\n![](https://upload-images.jianshu.io/upload_images/5106777-572053c97e185d26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nplus函数就包含了它上一层的作用域中的变量age，但由于plus函数也是局部作用域中，所以每次访问也是同样的值，如果能够将plus这个操作，做成类似全局作用域，那么每次执行就不会是重复的值了\n![闭包实际就是将局部作用域的集合调到全局作用域中，使局部作用域中的变量不被销毁](https://upload-images.jianshu.io/upload_images/5106777-5a8252d93a79bb09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n闭包是解决这个问题的一个方法，用立即执行函数返回的一个函数，成为了全局作用域下的一个变量集合，集合也可以是函数噢，所以，这个函数内部使用的变量，虽然是在局部作用域下的，但是却不会被销毁。\n\n这两个作用域基本上就是es5中经常使用的了，在es6中，新增了块状作用域， 起初我以为这个作用域的规则是针对所有变量的，但经过试验，这个规则主要配合`let`声明的变量使用，用来解决以前es5中一些场景下变量使用的作用域模糊不清的问题，比如常见的这种\n```\nfor(var i = 0;i < 3;i++){}\nconsole.log(i)  //3\n```\n如果换成let来声明i变量，就会报错`ReferenceError`，另外还有一种变量声明const，同样受此规则限制，所以，用let，const声明的变量仅在当前`{}`中可以访问。\n\n大概就说这些作用域了，总结：**作用域是变量在一段代码中的访问规则，是可访问变量的集合**。","source":"_posts/ES6项目学习笔记（一）作用域-定义的补充完善.md","raw":"---\ntitle: ES6项目学习笔记（一）作用域 定义的补充完善\ndate: 2019-11-18 16:13:20\ntags:\n---\n作用域是什么？\n抱着这个疑问，咱们不妨先看看下面的一段代码\n```\nvar name = 'tony';\nfunction hello(age){\n\tconsole.log(name);\n\tconsole.log(age);\n\tconsole.log(fullName);\n}\nhello();\n//tony\n//undefined\n//fullName is not defined\n```\n![实际运行结果](https://upload-images.jianshu.io/upload_images/5106777-26d49a73643e41b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n如果不了解作用域的看到代码可能会和我一样疑惑，为什么fullname“no defined”而age是\"undefined\"，有什么区别，以及为啥是\"no defined\"？\n有了这样的疑问我们再来看看我们所看到的一些解释：\n![作用域解释1](https://upload-images.jianshu.io/upload_images/5106777-482ac5610c5afe2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![作用域解释2](https://upload-images.jianshu.io/upload_images/5106777-9fe6c719aba92a08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n从这个两个解释里面我们可以提取出来两个要点，**规则** **集合**\n\n规则其实不难理解，就如同我们人在社会中一样，受到各种规则限制，而在js中处处存在的变量，也同样受到一套规则所限，同样有“生老病死”（变量生命周期），同样有自己的“人生轨迹”（作用域链）。\n在js中变量所受的作用域规则主要有了 **全局作用域**，**局部作用域**，**块状作用域**，**动态作用域**，\n\n这些作用域在上面的代码就有体现，我们可以先从我们最容易看懂的name变量入手，变量name是在整个代码中的最外层的,即在**函数外**,**代码块``{}``外**(es6新增)的,这就是全局作用域.\n我们说作用域是变量在整个js代码中运行的规则，这时候name在全局作用域的规则下就是：**网页中所有脚本和函数均可使用**，\n![全局作用域声明的变量可以在函数内部修改](https://upload-images.jianshu.io/upload_images/5106777-b9b9a3344fec8a1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n我们再把这段代码修改一下，就可以通过对比加深对全局作用域的理解，同时知道什么是函数作用域了\n![全局作用域的变量和函数作用域的变量](https://upload-images.jianshu.io/upload_images/5106777-9fd270f73dd404b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n函数内部定义的变量age，**在函数内部定义**的，就是局部作用域，很明显，它的规则就是**只能在函数内部访问**，你看在其它函数内修改也改变不了内部27的事实。在修改age的这个函数内，涉及到了js的变量提升编译词法等（[看这里](https://www.runoob.com/js/js-hoisting.html)），你在函数外打印age这个变量是可以得到20的，这更加说明了作用域的存在，超出了作用域，即便名字相同，也是不同的变量。这也是由于不同作用域可访问的变量不同导致的，可以再看一眼作用域的解释：\n![作用域为可访问对象，变量，函数的集合](https://upload-images.jianshu.io/upload_images/5106777-2379c3518739236a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n在函数内部，存在的可访问变量有name，age，在函数内部查找不到name这个变量时，会找到上一层全局作用域中，而查找age时，在局部作用域中就找到了，所以不会再在全局作用域中进行查找。\n作为局部作用域定义的变量可以很好的受到保护，不在外部就被随意更改，但是比如年龄这个东西，总不能每年询问的时候总是那个岁数吧\n![局部作用域的变量每次访问都被重置](https://upload-images.jianshu.io/upload_images/5106777-5e7d373f0a1fc8c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n所以我们需要每次访问的时候让函数内部自己+1。类似这样\n![](https://upload-images.jianshu.io/upload_images/5106777-572053c97e185d26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nplus函数就包含了它上一层的作用域中的变量age，但由于plus函数也是局部作用域中，所以每次访问也是同样的值，如果能够将plus这个操作，做成类似全局作用域，那么每次执行就不会是重复的值了\n![闭包实际就是将局部作用域的集合调到全局作用域中，使局部作用域中的变量不被销毁](https://upload-images.jianshu.io/upload_images/5106777-5a8252d93a79bb09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n闭包是解决这个问题的一个方法，用立即执行函数返回的一个函数，成为了全局作用域下的一个变量集合，集合也可以是函数噢，所以，这个函数内部使用的变量，虽然是在局部作用域下的，但是却不会被销毁。\n\n这两个作用域基本上就是es5中经常使用的了，在es6中，新增了块状作用域， 起初我以为这个作用域的规则是针对所有变量的，但经过试验，这个规则主要配合`let`声明的变量使用，用来解决以前es5中一些场景下变量使用的作用域模糊不清的问题，比如常见的这种\n```\nfor(var i = 0;i < 3;i++){}\nconsole.log(i)  //3\n```\n如果换成let来声明i变量，就会报错`ReferenceError`，另外还有一种变量声明const，同样受此规则限制，所以，用let，const声明的变量仅在当前`{}`中可以访问。\n\n大概就说这些作用域了，总结：**作用域是变量在一段代码中的访问规则，是可访问变量的集合**。","slug":"ES6项目学习笔记（一）作用域-定义的补充完善","published":1,"updated":"2019-11-18T08:15:47.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck34bmw840000ycrwn43id0ox","content":"<p>作用域是什么？<br>抱着这个疑问，咱们不妨先看看下面的一段代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &apos;tony&apos;;</span><br><span class=\"line\">function hello(age)&#123;</span><br><span class=\"line\">\tconsole.log(name);</span><br><span class=\"line\">\tconsole.log(age);</span><br><span class=\"line\">\tconsole.log(fullName);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello();</span><br><span class=\"line\">//tony</span><br><span class=\"line\">//undefined</span><br><span class=\"line\">//fullName is not defined</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5106777-26d49a73643e41b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"实际运行结果\"><br>如果不了解作用域的看到代码可能会和我一样疑惑，为什么fullname“no defined”而age是”undefined”，有什么区别，以及为啥是”no defined”？<br>有了这样的疑问我们再来看看我们所看到的一些解释：<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-482ac5610c5afe2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"作用域解释1\"><br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-9fe6c719aba92a08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"作用域解释2\"><br>从这个两个解释里面我们可以提取出来两个要点，<strong>规则</strong> <strong>集合</strong></p>\n<p>规则其实不难理解，就如同我们人在社会中一样，受到各种规则限制，而在js中处处存在的变量，也同样受到一套规则所限，同样有“生老病死”（变量生命周期），同样有自己的“人生轨迹”（作用域链）。<br>在js中变量所受的作用域规则主要有了 <strong>全局作用域</strong>，<strong>局部作用域</strong>，<strong>块状作用域</strong>，<strong>动态作用域</strong>，</p>\n<p>这些作用域在上面的代码就有体现，我们可以先从我们最容易看懂的name变量入手，变量name是在整个代码中的最外层的,即在<strong>函数外</strong>,<strong>代码块<code>{}</code>外</strong>(es6新增)的,这就是全局作用域.<br>我们说作用域是变量在整个js代码中运行的规则，这时候name在全局作用域的规则下就是：<strong>网页中所有脚本和函数均可使用</strong>，<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-b9b9a3344fec8a1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"全局作用域声明的变量可以在函数内部修改\"><br>我们再把这段代码修改一下，就可以通过对比加深对全局作用域的理解，同时知道什么是函数作用域了<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-9fd270f73dd404b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"全局作用域的变量和函数作用域的变量\"><br>函数内部定义的变量age，<strong>在函数内部定义</strong>的，就是局部作用域，很明显，它的规则就是<strong>只能在函数内部访问</strong>，你看在其它函数内修改也改变不了内部27的事实。在修改age的这个函数内，涉及到了js的变量提升编译词法等（<a href=\"https://www.runoob.com/js/js-hoisting.html\" target=\"_blank\" rel=\"noopener\">看这里</a>），你在函数外打印age这个变量是可以得到20的，这更加说明了作用域的存在，超出了作用域，即便名字相同，也是不同的变量。这也是由于不同作用域可访问的变量不同导致的，可以再看一眼作用域的解释：<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-2379c3518739236a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"作用域为可访问对象，变量，函数的集合\"><br>在函数内部，存在的可访问变量有name，age，在函数内部查找不到name这个变量时，会找到上一层全局作用域中，而查找age时，在局部作用域中就找到了，所以不会再在全局作用域中进行查找。<br>作为局部作用域定义的变量可以很好的受到保护，不在外部就被随意更改，但是比如年龄这个东西，总不能每年询问的时候总是那个岁数吧<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-5e7d373f0a1fc8c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"局部作用域的变量每次访问都被重置\"><br>所以我们需要每次访问的时候让函数内部自己+1。类似这样<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-572053c97e185d26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt><br>plus函数就包含了它上一层的作用域中的变量age，但由于plus函数也是局部作用域中，所以每次访问也是同样的值，如果能够将plus这个操作，做成类似全局作用域，那么每次执行就不会是重复的值了<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-5a8252d93a79bb09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"闭包实际就是将局部作用域的集合调到全局作用域中，使局部作用域中的变量不被销毁\"><br>闭包是解决这个问题的一个方法，用立即执行函数返回的一个函数，成为了全局作用域下的一个变量集合，集合也可以是函数噢，所以，这个函数内部使用的变量，虽然是在局部作用域下的，但是却不会被销毁。</p>\n<p>这两个作用域基本上就是es5中经常使用的了，在es6中，新增了块状作用域， 起初我以为这个作用域的规则是针对所有变量的，但经过试验，这个规则主要配合<code>let</code>声明的变量使用，用来解决以前es5中一些场景下变量使用的作用域模糊不清的问题，比如常见的这种</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(var i = 0;i &lt; 3;i++)&#123;&#125;</span><br><span class=\"line\">console.log(i)  //3</span><br></pre></td></tr></table></figure>\n\n<p>如果换成let来声明i变量，就会报错<code>ReferenceError</code>，另外还有一种变量声明const，同样受此规则限制，所以，用let，const声明的变量仅在当前<code>{}</code>中可以访问。</p>\n<p>大概就说这些作用域了，总结：<strong>作用域是变量在一段代码中的访问规则，是可访问变量的集合</strong>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>作用域是什么？<br>抱着这个疑问，咱们不妨先看看下面的一段代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &apos;tony&apos;;</span><br><span class=\"line\">function hello(age)&#123;</span><br><span class=\"line\">\tconsole.log(name);</span><br><span class=\"line\">\tconsole.log(age);</span><br><span class=\"line\">\tconsole.log(fullName);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello();</span><br><span class=\"line\">//tony</span><br><span class=\"line\">//undefined</span><br><span class=\"line\">//fullName is not defined</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5106777-26d49a73643e41b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"实际运行结果\"><br>如果不了解作用域的看到代码可能会和我一样疑惑，为什么fullname“no defined”而age是”undefined”，有什么区别，以及为啥是”no defined”？<br>有了这样的疑问我们再来看看我们所看到的一些解释：<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-482ac5610c5afe2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"作用域解释1\"><br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-9fe6c719aba92a08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"作用域解释2\"><br>从这个两个解释里面我们可以提取出来两个要点，<strong>规则</strong> <strong>集合</strong></p>\n<p>规则其实不难理解，就如同我们人在社会中一样，受到各种规则限制，而在js中处处存在的变量，也同样受到一套规则所限，同样有“生老病死”（变量生命周期），同样有自己的“人生轨迹”（作用域链）。<br>在js中变量所受的作用域规则主要有了 <strong>全局作用域</strong>，<strong>局部作用域</strong>，<strong>块状作用域</strong>，<strong>动态作用域</strong>，</p>\n<p>这些作用域在上面的代码就有体现，我们可以先从我们最容易看懂的name变量入手，变量name是在整个代码中的最外层的,即在<strong>函数外</strong>,<strong>代码块<code>{}</code>外</strong>(es6新增)的,这就是全局作用域.<br>我们说作用域是变量在整个js代码中运行的规则，这时候name在全局作用域的规则下就是：<strong>网页中所有脚本和函数均可使用</strong>，<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-b9b9a3344fec8a1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"全局作用域声明的变量可以在函数内部修改\"><br>我们再把这段代码修改一下，就可以通过对比加深对全局作用域的理解，同时知道什么是函数作用域了<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-9fd270f73dd404b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"全局作用域的变量和函数作用域的变量\"><br>函数内部定义的变量age，<strong>在函数内部定义</strong>的，就是局部作用域，很明显，它的规则就是<strong>只能在函数内部访问</strong>，你看在其它函数内修改也改变不了内部27的事实。在修改age的这个函数内，涉及到了js的变量提升编译词法等（<a href=\"https://www.runoob.com/js/js-hoisting.html\" target=\"_blank\" rel=\"noopener\">看这里</a>），你在函数外打印age这个变量是可以得到20的，这更加说明了作用域的存在，超出了作用域，即便名字相同，也是不同的变量。这也是由于不同作用域可访问的变量不同导致的，可以再看一眼作用域的解释：<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-2379c3518739236a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"作用域为可访问对象，变量，函数的集合\"><br>在函数内部，存在的可访问变量有name，age，在函数内部查找不到name这个变量时，会找到上一层全局作用域中，而查找age时，在局部作用域中就找到了，所以不会再在全局作用域中进行查找。<br>作为局部作用域定义的变量可以很好的受到保护，不在外部就被随意更改，但是比如年龄这个东西，总不能每年询问的时候总是那个岁数吧<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-5e7d373f0a1fc8c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"局部作用域的变量每次访问都被重置\"><br>所以我们需要每次访问的时候让函数内部自己+1。类似这样<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-572053c97e185d26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt><br>plus函数就包含了它上一层的作用域中的变量age，但由于plus函数也是局部作用域中，所以每次访问也是同样的值，如果能够将plus这个操作，做成类似全局作用域，那么每次执行就不会是重复的值了<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-5a8252d93a79bb09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"闭包实际就是将局部作用域的集合调到全局作用域中，使局部作用域中的变量不被销毁\"><br>闭包是解决这个问题的一个方法，用立即执行函数返回的一个函数，成为了全局作用域下的一个变量集合，集合也可以是函数噢，所以，这个函数内部使用的变量，虽然是在局部作用域下的，但是却不会被销毁。</p>\n<p>这两个作用域基本上就是es5中经常使用的了，在es6中，新增了块状作用域， 起初我以为这个作用域的规则是针对所有变量的，但经过试验，这个规则主要配合<code>let</code>声明的变量使用，用来解决以前es5中一些场景下变量使用的作用域模糊不清的问题，比如常见的这种</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(var i = 0;i &lt; 3;i++)&#123;&#125;</span><br><span class=\"line\">console.log(i)  //3</span><br></pre></td></tr></table></figure>\n\n<p>如果换成let来声明i变量，就会报错<code>ReferenceError</code>，另外还有一种变量声明const，同样受此规则限制，所以，用let，const声明的变量仅在当前<code>{}</code>中可以访问。</p>\n<p>大概就说这些作用域了，总结：<strong>作用域是变量在一段代码中的访问规则，是可访问变量的集合</strong>。</p>\n"},{"title":"ES6项目学习笔记（二）let和const 变量声明的扩展","date":"2019-11-18T08:13:46.000Z","_content":"let，const和var一样，是对变量的一种声明方式，都可以用来声明变量。\n先说说let，用来**声明仅可在块状作用域中使用的变量**。直接上代码说：\n![var声明的变量不受块状作用域限制](https://upload-images.jianshu.io/upload_images/5106777-749435c595b5b095.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n所以，不在块状作用域用，let就没什么意义。\n另外,同一作用域内,不能用let反复声明同一个变量,会报错的\n![](https://upload-images.jianshu.io/upload_images/5106777-4a36eaaba24ca8ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n用*const*用来声明创建一个常量,除了同一作用域下不能反复声明,还不能重新赋值,这里的值指的是变量引用的内存地址,在引用内容是对象的情况下，可以改变对象里面的内容,看代码就清楚了:\n![](https://upload-images.jianshu.io/upload_images/5106777-bf8bb8d7ba540abb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n以上，有其它的再讨论补充。","source":"_posts/ES6项目学习笔记（二）let和const-变量声明的扩展.md","raw":"---\ntitle: ES6项目学习笔记（二）let和const 变量声明的扩展\ndate: 2019-11-18 16:13:46\ntags:\n---\nlet，const和var一样，是对变量的一种声明方式，都可以用来声明变量。\n先说说let，用来**声明仅可在块状作用域中使用的变量**。直接上代码说：\n![var声明的变量不受块状作用域限制](https://upload-images.jianshu.io/upload_images/5106777-749435c595b5b095.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n所以，不在块状作用域用，let就没什么意义。\n另外,同一作用域内,不能用let反复声明同一个变量,会报错的\n![](https://upload-images.jianshu.io/upload_images/5106777-4a36eaaba24ca8ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n用*const*用来声明创建一个常量,除了同一作用域下不能反复声明,还不能重新赋值,这里的值指的是变量引用的内存地址,在引用内容是对象的情况下，可以改变对象里面的内容,看代码就清楚了:\n![](https://upload-images.jianshu.io/upload_images/5106777-bf8bb8d7ba540abb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n以上，有其它的再讨论补充。","slug":"ES6项目学习笔记（二）let和const-变量声明的扩展","published":1,"updated":"2019-11-18T08:15:48.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck34bmw8a0001ycrwrdptg6jy","content":"<p>let，const和var一样，是对变量的一种声明方式，都可以用来声明变量。<br>先说说let，用来<strong>声明仅可在块状作用域中使用的变量</strong>。直接上代码说：<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-749435c595b5b095.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"var声明的变量不受块状作用域限制\"><br>所以，不在块状作用域用，let就没什么意义。<br>另外,同一作用域内,不能用let反复声明同一个变量,会报错的<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-4a36eaaba24ca8ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt><br>用<em>const</em>用来声明创建一个常量,除了同一作用域下不能反复声明,还不能重新赋值,这里的值指的是变量引用的内存地址,在引用内容是对象的情况下，可以改变对象里面的内容,看代码就清楚了:<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-bf8bb8d7ba540abb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt><br>以上，有其它的再讨论补充。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>let，const和var一样，是对变量的一种声明方式，都可以用来声明变量。<br>先说说let，用来<strong>声明仅可在块状作用域中使用的变量</strong>。直接上代码说：<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-749435c595b5b095.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"var声明的变量不受块状作用域限制\"><br>所以，不在块状作用域用，let就没什么意义。<br>另外,同一作用域内,不能用let反复声明同一个变量,会报错的<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-4a36eaaba24ca8ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt><br>用<em>const</em>用来声明创建一个常量,除了同一作用域下不能反复声明,还不能重新赋值,这里的值指的是变量引用的内存地址,在引用内容是对象的情况下，可以改变对象里面的内容,看代码就清楚了:<br><img src=\"https://upload-images.jianshu.io/upload_images/5106777-bf8bb8d7ba540abb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt><br>以上，有其它的再讨论补充。</p>\n"},{"title":"ES项目学习笔记（三）赋值操作更简便 解构赋值","date":"2019-11-18T08:16:55.000Z","_content":"用一个经常遇到的问题来说明这一赋值的好处之一，**对两个变量的值进行替换**，通常我们得另外声明一个变量来作为两个变量交换的媒介，而现在如下代码就可以解决：\n```\n{\n  let a=1;\n  let b=2;\n  [a,b]=[b,a];\n  console.log(a,b);  //2,1\n}\n```\n解构赋值上述的用法是对**数组的解构赋值**，总的来说结构赋值大致可以分为**数组解构赋值**，**对象解构赋值**，**字符解构赋值**，**数值和布尔解构赋值**，**函数参数解构赋值**。\n\n无论何种解构赋值，解构赋值表达式的左边部分，即**解构的目标**，而右边的值，即左边**解构的源**，都遵循一个左右互相匹配的规则，只要等号两边的模式相同，左边的变量就会被赋予对应的值。\n\n#### 数组解构赋值\n上述的代码就是数组解构赋值的**基本用法**。以下是数组解构赋值的其它使用方式\n```\n//嵌套\n{\n  let [a, [[b], c]] = [1, [[2], 3]];\n  console.log(a,b,c); //1,2,3\n}\n//可忽略\n{\n  let [a, , b] = [1, 2, 3];\n  console.log(a,b);\n}\n//剩余运算符\n{\n  let a,b,rest;\n  [a,b,...rest] = [1,2,3,4,5,6];\n  console.log(a,b,rest); //1,2,[4,5,6]\n}\n//不完全解构\n{\n\tlet [a,b] = [1,2,3];\n}\n```\n上述的变量全都可以成功赋值，也就是成功解构，但也有无法解构成功的，比如：\n```\nlet [a] = [];\nlet [b, d,...c] = [1];\nconsole.log(a);  //undefined\nconsole.log(b,d,c); //1,undefined,[]\n```\n当解构目标在解构的源对应位置找不到值,则无法成功解构,变量的值就会变成`undefined`,...剩余运算符的变量为`[]`.\n在实际开发场景中返回的值可能有多种情况,可能你想要的值在某个位置确实没有,那么还可以使用**默认值**。\n```\nlet [a,b = 1] = [1];\nconsole.log(a,b); //1,1\nlet [c = 1,d = 2] = [undefined,null];\nconsole.log(c,d); //1,null\n```\n*ES6 内部使用严格相等运算符（===），判断一个位置是否有值。只有当一个数组成员严格等于`undefined`，默认值才会生效*\n默认值可以引用解构赋值的其他变量，但该变量必须已经声明。\n```\nlet [a = 1, b = a] = [];     // a=1; b=1\nlet [a = 1, b = a] = [2];    // a=2; b=2\nlet [a = 1, b = a] = [1, 2]; // a=1; b=2\nlet [a = b, b = 1] = [];     // ReferenceError: b is not defined\n```\n如果解构的源不是数组，就会报错\n```\nlet [foo] = 1;\nlet [foo] = false;\nlet [foo] = NaN;\nlet [foo] = undefined;\nlet [foo] = null;\nlet [foo] = {};\n```\n#### 对象解构赋值\n对象解构赋值同样遵循左右互相匹配的规则，类似数组一样有嵌套，默认值等，但要注意的是变量名称需要和对象中的属性值要对应，因为数组的位置相对应来说是有序的，而对象中是无序的，只能通过属性来作为位置查找，如果要使用其它的变量名称，可以使用`:`重新指定变量名称，注意此时引用地址已被新变量接收,`:`左边的变量就没有地址了，再访问的话是空的,在下面示例代码中有对应的写法：\n```\n//基本\n{\n  let {a,b} = {a:1,b:2}\n  console.log(a,b);\n  let {name:newName} = {name:'tony'}\n  console.log(name)//\n  console.log(newName)//tony\n}\n//嵌套\n{\n\tlet {a,c:}\n}\n```\n#### 字符解构赋值\n#### 数组解构赋值","source":"_posts/ES项目学习笔记（三）赋值操作更简便-解构赋值.md","raw":"---\ntitle: ES项目学习笔记（三）赋值操作更简便 解构赋值\ndate: 2019-11-18 16:16:55\ntags:\n---\n用一个经常遇到的问题来说明这一赋值的好处之一，**对两个变量的值进行替换**，通常我们得另外声明一个变量来作为两个变量交换的媒介，而现在如下代码就可以解决：\n```\n{\n  let a=1;\n  let b=2;\n  [a,b]=[b,a];\n  console.log(a,b);  //2,1\n}\n```\n解构赋值上述的用法是对**数组的解构赋值**，总的来说结构赋值大致可以分为**数组解构赋值**，**对象解构赋值**，**字符解构赋值**，**数值和布尔解构赋值**，**函数参数解构赋值**。\n\n无论何种解构赋值，解构赋值表达式的左边部分，即**解构的目标**，而右边的值，即左边**解构的源**，都遵循一个左右互相匹配的规则，只要等号两边的模式相同，左边的变量就会被赋予对应的值。\n\n#### 数组解构赋值\n上述的代码就是数组解构赋值的**基本用法**。以下是数组解构赋值的其它使用方式\n```\n//嵌套\n{\n  let [a, [[b], c]] = [1, [[2], 3]];\n  console.log(a,b,c); //1,2,3\n}\n//可忽略\n{\n  let [a, , b] = [1, 2, 3];\n  console.log(a,b);\n}\n//剩余运算符\n{\n  let a,b,rest;\n  [a,b,...rest] = [1,2,3,4,5,6];\n  console.log(a,b,rest); //1,2,[4,5,6]\n}\n//不完全解构\n{\n\tlet [a,b] = [1,2,3];\n}\n```\n上述的变量全都可以成功赋值，也就是成功解构，但也有无法解构成功的，比如：\n```\nlet [a] = [];\nlet [b, d,...c] = [1];\nconsole.log(a);  //undefined\nconsole.log(b,d,c); //1,undefined,[]\n```\n当解构目标在解构的源对应位置找不到值,则无法成功解构,变量的值就会变成`undefined`,...剩余运算符的变量为`[]`.\n在实际开发场景中返回的值可能有多种情况,可能你想要的值在某个位置确实没有,那么还可以使用**默认值**。\n```\nlet [a,b = 1] = [1];\nconsole.log(a,b); //1,1\nlet [c = 1,d = 2] = [undefined,null];\nconsole.log(c,d); //1,null\n```\n*ES6 内部使用严格相等运算符（===），判断一个位置是否有值。只有当一个数组成员严格等于`undefined`，默认值才会生效*\n默认值可以引用解构赋值的其他变量，但该变量必须已经声明。\n```\nlet [a = 1, b = a] = [];     // a=1; b=1\nlet [a = 1, b = a] = [2];    // a=2; b=2\nlet [a = 1, b = a] = [1, 2]; // a=1; b=2\nlet [a = b, b = 1] = [];     // ReferenceError: b is not defined\n```\n如果解构的源不是数组，就会报错\n```\nlet [foo] = 1;\nlet [foo] = false;\nlet [foo] = NaN;\nlet [foo] = undefined;\nlet [foo] = null;\nlet [foo] = {};\n```\n#### 对象解构赋值\n对象解构赋值同样遵循左右互相匹配的规则，类似数组一样有嵌套，默认值等，但要注意的是变量名称需要和对象中的属性值要对应，因为数组的位置相对应来说是有序的，而对象中是无序的，只能通过属性来作为位置查找，如果要使用其它的变量名称，可以使用`:`重新指定变量名称，注意此时引用地址已被新变量接收,`:`左边的变量就没有地址了，再访问的话是空的,在下面示例代码中有对应的写法：\n```\n//基本\n{\n  let {a,b} = {a:1,b:2}\n  console.log(a,b);\n  let {name:newName} = {name:'tony'}\n  console.log(name)//\n  console.log(newName)//tony\n}\n//嵌套\n{\n\tlet {a,c:}\n}\n```\n#### 字符解构赋值\n#### 数组解构赋值","slug":"ES项目学习笔记（三）赋值操作更简便-解构赋值","published":1,"updated":"2019-11-18T11:03:30.645Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck34bmw8e0002ycrwzhp1e1m6","content":"<p>用一个经常遇到的问题来说明这一赋值的好处之一，<strong>对两个变量的值进行替换</strong>，通常我们得另外声明一个变量来作为两个变量交换的媒介，而现在如下代码就可以解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  let a=1;</span><br><span class=\"line\">  let b=2;</span><br><span class=\"line\">  [a,b]=[b,a];</span><br><span class=\"line\">  console.log(a,b);  //2,1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解构赋值上述的用法是对<strong>数组的解构赋值</strong>，总的来说结构赋值大致可以分为<strong>数组解构赋值</strong>，<strong>对象解构赋值</strong>，<strong>字符解构赋值</strong>，<strong>数值和布尔解构赋值</strong>，<strong>函数参数解构赋值</strong>。</p>\n<p>无论何种解构赋值，解构赋值表达式的左边部分，即<strong>解构的目标</strong>，而右边的值，即左边<strong>解构的源</strong>，都遵循一个左右互相匹配的规则，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p>\n<h4 id=\"数组解构赋值\"><a href=\"#数组解构赋值\" class=\"headerlink\" title=\"数组解构赋值\"></a>数组解构赋值</h4><p>上述的代码就是数组解构赋值的<strong>基本用法</strong>。以下是数组解构赋值的其它使用方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//嵌套</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  let [a, [[b], c]] = [1, [[2], 3]];</span><br><span class=\"line\">  console.log(a,b,c); //1,2,3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//可忽略</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  let [a, , b] = [1, 2, 3];</span><br><span class=\"line\">  console.log(a,b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//剩余运算符</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  let a,b,rest;</span><br><span class=\"line\">  [a,b,...rest] = [1,2,3,4,5,6];</span><br><span class=\"line\">  console.log(a,b,rest); //1,2,[4,5,6]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//不完全解构</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tlet [a,b] = [1,2,3];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述的变量全都可以成功赋值，也就是成功解构，但也有无法解构成功的，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [a] = [];</span><br><span class=\"line\">let [b, d,...c] = [1];</span><br><span class=\"line\">console.log(a);  //undefined</span><br><span class=\"line\">console.log(b,d,c); //1,undefined,[]</span><br></pre></td></tr></table></figure>\n\n<p>当解构目标在解构的源对应位置找不到值,则无法成功解构,变量的值就会变成<code>undefined</code>,…剩余运算符的变量为<code>[]</code>.<br>在实际开发场景中返回的值可能有多种情况,可能你想要的值在某个位置确实没有,那么还可以使用<strong>默认值</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [a,b = 1] = [1];</span><br><span class=\"line\">console.log(a,b); //1,1</span><br><span class=\"line\">let [c = 1,d = 2] = [undefined,null];</span><br><span class=\"line\">console.log(c,d); //1,null</span><br></pre></td></tr></table></figure>\n\n<p><em>ES6 内部使用严格相等运算符（===），判断一个位置是否有值。只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效</em><br>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [a = 1, b = a] = [];     // a=1; b=1</span><br><span class=\"line\">let [a = 1, b = a] = [2];    // a=2; b=2</span><br><span class=\"line\">let [a = 1, b = a] = [1, 2]; // a=1; b=2</span><br><span class=\"line\">let [a = b, b = 1] = [];     // ReferenceError: b is not defined</span><br></pre></td></tr></table></figure>\n\n<p>如果解构的源不是数组，就会报错</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [foo] = 1;</span><br><span class=\"line\">let [foo] = false;</span><br><span class=\"line\">let [foo] = NaN;</span><br><span class=\"line\">let [foo] = undefined;</span><br><span class=\"line\">let [foo] = null;</span><br><span class=\"line\">let [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"对象解构赋值\"><a href=\"#对象解构赋值\" class=\"headerlink\" title=\"对象解构赋值\"></a>对象解构赋值</h4><p>对象解构赋值同样遵循左右互相匹配的规则，类似数组一样有嵌套，默认值等，但要注意的是变量名称需要和对象中的属性值要对应，因为数组的位置相对应来说是有序的，而对象中是无序的，只能通过属性来作为位置查找，如果要使用其它的变量名称，可以使用<code>:</code>重新指定变量名称，注意此时引用地址已被新变量接收,<code>:</code>左边的变量就没有地址了，再访问的话是空的,在下面示例代码中有对应的写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//基本</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  let &#123;a,b&#125; = &#123;a:1,b:2&#125;</span><br><span class=\"line\">  console.log(a,b);</span><br><span class=\"line\">  let &#123;name:newName&#125; = &#123;name:&apos;tony&apos;&#125;</span><br><span class=\"line\">  console.log(name)//</span><br><span class=\"line\">  console.log(newName)//tony</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//嵌套</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tlet &#123;a,c:&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"字符解构赋值\"><a href=\"#字符解构赋值\" class=\"headerlink\" title=\"字符解构赋值\"></a>字符解构赋值</h4><h4 id=\"数组解构赋值-1\"><a href=\"#数组解构赋值-1\" class=\"headerlink\" title=\"数组解构赋值\"></a>数组解构赋值</h4>","site":{"data":{}},"excerpt":"","more":"<p>用一个经常遇到的问题来说明这一赋值的好处之一，<strong>对两个变量的值进行替换</strong>，通常我们得另外声明一个变量来作为两个变量交换的媒介，而现在如下代码就可以解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  let a=1;</span><br><span class=\"line\">  let b=2;</span><br><span class=\"line\">  [a,b]=[b,a];</span><br><span class=\"line\">  console.log(a,b);  //2,1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解构赋值上述的用法是对<strong>数组的解构赋值</strong>，总的来说结构赋值大致可以分为<strong>数组解构赋值</strong>，<strong>对象解构赋值</strong>，<strong>字符解构赋值</strong>，<strong>数值和布尔解构赋值</strong>，<strong>函数参数解构赋值</strong>。</p>\n<p>无论何种解构赋值，解构赋值表达式的左边部分，即<strong>解构的目标</strong>，而右边的值，即左边<strong>解构的源</strong>，都遵循一个左右互相匹配的规则，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p>\n<h4 id=\"数组解构赋值\"><a href=\"#数组解构赋值\" class=\"headerlink\" title=\"数组解构赋值\"></a>数组解构赋值</h4><p>上述的代码就是数组解构赋值的<strong>基本用法</strong>。以下是数组解构赋值的其它使用方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//嵌套</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  let [a, [[b], c]] = [1, [[2], 3]];</span><br><span class=\"line\">  console.log(a,b,c); //1,2,3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//可忽略</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  let [a, , b] = [1, 2, 3];</span><br><span class=\"line\">  console.log(a,b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//剩余运算符</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  let a,b,rest;</span><br><span class=\"line\">  [a,b,...rest] = [1,2,3,4,5,6];</span><br><span class=\"line\">  console.log(a,b,rest); //1,2,[4,5,6]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//不完全解构</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tlet [a,b] = [1,2,3];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述的变量全都可以成功赋值，也就是成功解构，但也有无法解构成功的，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [a] = [];</span><br><span class=\"line\">let [b, d,...c] = [1];</span><br><span class=\"line\">console.log(a);  //undefined</span><br><span class=\"line\">console.log(b,d,c); //1,undefined,[]</span><br></pre></td></tr></table></figure>\n\n<p>当解构目标在解构的源对应位置找不到值,则无法成功解构,变量的值就会变成<code>undefined</code>,…剩余运算符的变量为<code>[]</code>.<br>在实际开发场景中返回的值可能有多种情况,可能你想要的值在某个位置确实没有,那么还可以使用<strong>默认值</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [a,b = 1] = [1];</span><br><span class=\"line\">console.log(a,b); //1,1</span><br><span class=\"line\">let [c = 1,d = 2] = [undefined,null];</span><br><span class=\"line\">console.log(c,d); //1,null</span><br></pre></td></tr></table></figure>\n\n<p><em>ES6 内部使用严格相等运算符（===），判断一个位置是否有值。只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效</em><br>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [a = 1, b = a] = [];     // a=1; b=1</span><br><span class=\"line\">let [a = 1, b = a] = [2];    // a=2; b=2</span><br><span class=\"line\">let [a = 1, b = a] = [1, 2]; // a=1; b=2</span><br><span class=\"line\">let [a = b, b = 1] = [];     // ReferenceError: b is not defined</span><br></pre></td></tr></table></figure>\n\n<p>如果解构的源不是数组，就会报错</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [foo] = 1;</span><br><span class=\"line\">let [foo] = false;</span><br><span class=\"line\">let [foo] = NaN;</span><br><span class=\"line\">let [foo] = undefined;</span><br><span class=\"line\">let [foo] = null;</span><br><span class=\"line\">let [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"对象解构赋值\"><a href=\"#对象解构赋值\" class=\"headerlink\" title=\"对象解构赋值\"></a>对象解构赋值</h4><p>对象解构赋值同样遵循左右互相匹配的规则，类似数组一样有嵌套，默认值等，但要注意的是变量名称需要和对象中的属性值要对应，因为数组的位置相对应来说是有序的，而对象中是无序的，只能通过属性来作为位置查找，如果要使用其它的变量名称，可以使用<code>:</code>重新指定变量名称，注意此时引用地址已被新变量接收,<code>:</code>左边的变量就没有地址了，再访问的话是空的,在下面示例代码中有对应的写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//基本</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  let &#123;a,b&#125; = &#123;a:1,b:2&#125;</span><br><span class=\"line\">  console.log(a,b);</span><br><span class=\"line\">  let &#123;name:newName&#125; = &#123;name:&apos;tony&apos;&#125;</span><br><span class=\"line\">  console.log(name)//</span><br><span class=\"line\">  console.log(newName)//tony</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//嵌套</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tlet &#123;a,c:&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"字符解构赋值\"><a href=\"#字符解构赋值\" class=\"headerlink\" title=\"字符解构赋值\"></a>字符解构赋值</h4><h4 id=\"数组解构赋值-1\"><a href=\"#数组解构赋值-1\" class=\"headerlink\" title=\"数组解构赋值\"></a>数组解构赋值</h4>"},{"title":"建立hexo个人博客过程记录","date":"2019-09-19T08:40:58.000Z","_content":"偶然在网上逛的时候看到的,饶有兴趣的尝试了一下,各种问题.\n\n先说结论:\n\n   - 看到什么文章写工具的使用的,先到人家官方api看吧,照着官方文档做,出什么问题再看文章博客,别人博客说不定也只是搬运人家官方文档而已;\n\n   - 写博客文章,我真想不明白Markdown这种编辑文章的方式怎么流行起来的,word编辑器不好用么.也可能是我刚上手不熟悉,也许熟悉了会快很多,那再说;\n\n   - 用第三方工具构建个人的技术博客,如果只是记录需要,简书,csdn,等等平台可以快速的记录并发表文章,可以不用这么麻烦去搭建.如果是想要开放性的DIY自己的个人博客,选择这个第三方工具可能不是最优选,至少看它官方文档并不是很好用啊.如果有更好的,请推荐下.\n\n贴上官方链接:[https://hexo.io/zh-cn/docs/](https://hexo.io/zh-cn/docs/)\n\n按官方文档的操作你可以很轻松的在本地跑起来(windows系统).如果没有跑起来,你可以注意一下:\n![](/blog/images/5106777-240a8745b1e195f1.png)\n\n然后就遇到第一个问题,路径问题.\n我在github上的项目路径其实是在![](/blog/images/5106777-2a92ba6f32a3d3f9.png)\n\n如果我在看那个博客之前就看了官方文档就好了,就不会部署到github上面样式什么的都出不来.其实文档上面对url路径有进行温馨的说明\n![这个配置在根目录的_config.yml文件中修改](/blog/images/5106777-b79265113319f19c.png)\n\n很好,解决完了这个之前,还有一个问题,在github上面的部署问题\n![](/blog/images/5106777-920c509dfffadc21.png)\n\n![](/blog/images/5106777-87cfc19d337ca8d1.png)\n当然现在解决完了绿了,之前的报错类似的意思就是服务器时区之类的,应该是,一堆英文看不懂\n![](/blog/images/5106777-a10e999040e7762c.png)\n解决方法就是在项目下新增一个文件名为.nojekyll的空文件\n![](/blog/images/5106777-cf08e99288003e68.png)\n\n上面的问题解决完,按照文档的敲命令部署推送,点开链接,美得很,搭建完成.\n\n但是,一件事情要做成功,往往离不开坚持,博客搭建好了,还需要内容的填充,按照文档创建了一遍文章,累得半死,费劲心思写下文章,又是一阵心累,希望我能长久的坚持下去吧...\n\n","source":"_posts/建立hexo个人博客过程记录.md","raw":"---\ntitle: 建立hexo个人博客过程记录\ndate: 2019-09-19 16:40:58\ntags:\n---\n偶然在网上逛的时候看到的,饶有兴趣的尝试了一下,各种问题.\n\n先说结论:\n\n   - 看到什么文章写工具的使用的,先到人家官方api看吧,照着官方文档做,出什么问题再看文章博客,别人博客说不定也只是搬运人家官方文档而已;\n\n   - 写博客文章,我真想不明白Markdown这种编辑文章的方式怎么流行起来的,word编辑器不好用么.也可能是我刚上手不熟悉,也许熟悉了会快很多,那再说;\n\n   - 用第三方工具构建个人的技术博客,如果只是记录需要,简书,csdn,等等平台可以快速的记录并发表文章,可以不用这么麻烦去搭建.如果是想要开放性的DIY自己的个人博客,选择这个第三方工具可能不是最优选,至少看它官方文档并不是很好用啊.如果有更好的,请推荐下.\n\n贴上官方链接:[https://hexo.io/zh-cn/docs/](https://hexo.io/zh-cn/docs/)\n\n按官方文档的操作你可以很轻松的在本地跑起来(windows系统).如果没有跑起来,你可以注意一下:\n![](/blog/images/5106777-240a8745b1e195f1.png)\n\n然后就遇到第一个问题,路径问题.\n我在github上的项目路径其实是在![](/blog/images/5106777-2a92ba6f32a3d3f9.png)\n\n如果我在看那个博客之前就看了官方文档就好了,就不会部署到github上面样式什么的都出不来.其实文档上面对url路径有进行温馨的说明\n![这个配置在根目录的_config.yml文件中修改](/blog/images/5106777-b79265113319f19c.png)\n\n很好,解决完了这个之前,还有一个问题,在github上面的部署问题\n![](/blog/images/5106777-920c509dfffadc21.png)\n\n![](/blog/images/5106777-87cfc19d337ca8d1.png)\n当然现在解决完了绿了,之前的报错类似的意思就是服务器时区之类的,应该是,一堆英文看不懂\n![](/blog/images/5106777-a10e999040e7762c.png)\n解决方法就是在项目下新增一个文件名为.nojekyll的空文件\n![](/blog/images/5106777-cf08e99288003e68.png)\n\n上面的问题解决完,按照文档的敲命令部署推送,点开链接,美得很,搭建完成.\n\n但是,一件事情要做成功,往往离不开坚持,博客搭建好了,还需要内容的填充,按照文档创建了一遍文章,累得半死,费劲心思写下文章,又是一阵心累,希望我能长久的坚持下去吧...\n\n","slug":"建立hexo个人博客过程记录","published":1,"updated":"2019-09-19T09:16:36.980Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck34bmw8g0003ycrwsh5t4yo0","content":"<p>偶然在网上逛的时候看到的,饶有兴趣的尝试了一下,各种问题.</p>\n<p>先说结论:</p>\n<ul>\n<li><p>看到什么文章写工具的使用的,先到人家官方api看吧,照着官方文档做,出什么问题再看文章博客,别人博客说不定也只是搬运人家官方文档而已;</p>\n</li>\n<li><p>写博客文章,我真想不明白Markdown这种编辑文章的方式怎么流行起来的,word编辑器不好用么.也可能是我刚上手不熟悉,也许熟悉了会快很多,那再说;</p>\n</li>\n<li><p>用第三方工具构建个人的技术博客,如果只是记录需要,简书,csdn,等等平台可以快速的记录并发表文章,可以不用这么麻烦去搭建.如果是想要开放性的DIY自己的个人博客,选择这个第三方工具可能不是最优选,至少看它官方文档并不是很好用啊.如果有更好的,请推荐下.</p>\n</li>\n</ul>\n<p>贴上官方链接:<a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"noopener\">https://hexo.io/zh-cn/docs/</a></p>\n<p>按官方文档的操作你可以很轻松的在本地跑起来(windows系统).如果没有跑起来,你可以注意一下:<br><img src=\"/blog/images/5106777-240a8745b1e195f1.png\" alt></p>\n<p>然后就遇到第一个问题,路径问题.<br>我在github上的项目路径其实是在<img src=\"/blog/images/5106777-2a92ba6f32a3d3f9.png\" alt></p>\n<p>如果我在看那个博客之前就看了官方文档就好了,就不会部署到github上面样式什么的都出不来.其实文档上面对url路径有进行温馨的说明<br><img src=\"/blog/images/5106777-b79265113319f19c.png\" alt=\"这个配置在根目录的_config.yml文件中修改\"></p>\n<p>很好,解决完了这个之前,还有一个问题,在github上面的部署问题<br><img src=\"/blog/images/5106777-920c509dfffadc21.png\" alt></p>\n<p><img src=\"/blog/images/5106777-87cfc19d337ca8d1.png\" alt><br>当然现在解决完了绿了,之前的报错类似的意思就是服务器时区之类的,应该是,一堆英文看不懂<br><img src=\"/blog/images/5106777-a10e999040e7762c.png\" alt><br>解决方法就是在项目下新增一个文件名为.nojekyll的空文件<br><img src=\"/blog/images/5106777-cf08e99288003e68.png\" alt></p>\n<p>上面的问题解决完,按照文档的敲命令部署推送,点开链接,美得很,搭建完成.</p>\n<p>但是,一件事情要做成功,往往离不开坚持,博客搭建好了,还需要内容的填充,按照文档创建了一遍文章,累得半死,费劲心思写下文章,又是一阵心累,希望我能长久的坚持下去吧…</p>\n","site":{"data":{}},"excerpt":"","more":"<p>偶然在网上逛的时候看到的,饶有兴趣的尝试了一下,各种问题.</p>\n<p>先说结论:</p>\n<ul>\n<li><p>看到什么文章写工具的使用的,先到人家官方api看吧,照着官方文档做,出什么问题再看文章博客,别人博客说不定也只是搬运人家官方文档而已;</p>\n</li>\n<li><p>写博客文章,我真想不明白Markdown这种编辑文章的方式怎么流行起来的,word编辑器不好用么.也可能是我刚上手不熟悉,也许熟悉了会快很多,那再说;</p>\n</li>\n<li><p>用第三方工具构建个人的技术博客,如果只是记录需要,简书,csdn,等等平台可以快速的记录并发表文章,可以不用这么麻烦去搭建.如果是想要开放性的DIY自己的个人博客,选择这个第三方工具可能不是最优选,至少看它官方文档并不是很好用啊.如果有更好的,请推荐下.</p>\n</li>\n</ul>\n<p>贴上官方链接:<a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"noopener\">https://hexo.io/zh-cn/docs/</a></p>\n<p>按官方文档的操作你可以很轻松的在本地跑起来(windows系统).如果没有跑起来,你可以注意一下:<br><img src=\"/blog/images/5106777-240a8745b1e195f1.png\" alt></p>\n<p>然后就遇到第一个问题,路径问题.<br>我在github上的项目路径其实是在<img src=\"/blog/images/5106777-2a92ba6f32a3d3f9.png\" alt></p>\n<p>如果我在看那个博客之前就看了官方文档就好了,就不会部署到github上面样式什么的都出不来.其实文档上面对url路径有进行温馨的说明<br><img src=\"/blog/images/5106777-b79265113319f19c.png\" alt=\"这个配置在根目录的_config.yml文件中修改\"></p>\n<p>很好,解决完了这个之前,还有一个问题,在github上面的部署问题<br><img src=\"/blog/images/5106777-920c509dfffadc21.png\" alt></p>\n<p><img src=\"/blog/images/5106777-87cfc19d337ca8d1.png\" alt><br>当然现在解决完了绿了,之前的报错类似的意思就是服务器时区之类的,应该是,一堆英文看不懂<br><img src=\"/blog/images/5106777-a10e999040e7762c.png\" alt><br>解决方法就是在项目下新增一个文件名为.nojekyll的空文件<br><img src=\"/blog/images/5106777-cf08e99288003e68.png\" alt></p>\n<p>上面的问题解决完,按照文档的敲命令部署推送,点开链接,美得很,搭建完成.</p>\n<p>但是,一件事情要做成功,往往离不开坚持,博客搭建好了,还需要内容的填充,按照文档创建了一遍文章,累得半死,费劲心思写下文章,又是一阵心累,希望我能长久的坚持下去吧…</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}