---
title: ES项目学习笔记（三）赋值操作更简便 解构赋值
date: 2019-11-18 16:16:55
tags:
---
用一个经常遇到的问题来说明这一赋值的好处之一，**对两个变量的值进行替换**，通常我们得另外声明一个变量来作为两个变量交换的媒介，而现在如下代码就可以解决：
```
{
  let a=1;
  let b=2;
  [a,b]=[b,a];
  console.log(a,b);  //2,1
}
```
解构赋值上述的用法是对**数组的解构赋值**，总的来说结构赋值大致可以分为**数组解构赋值**，**对象解构赋值**，**字符解构赋值**，**数值和布尔解构赋值**，**函数参数解构赋值**。

无论何种解构赋值，解构赋值表达式的左边部分，即**解构的目标**，而右边的值，即左边**解构的源**，都遵循一个左右互相匹配的规则，只要等号两边的模式相同，左边的变量就会被赋予对应的值。

#### 数组解构赋值
上述的代码就是数组解构赋值的**基本用法**。以下是数组解构赋值的其它使用方式
```
//嵌套
{
  let [a, [[b], c]] = [1, [[2], 3]];
  console.log(a,b,c); //1,2,3
}
//可忽略
{
  let [a, , b] = [1, 2, 3];
  console.log(a,b);
}
//剩余运算符
{
  let a,b,rest;
  [a,b,...rest] = [1,2,3,4,5,6];
  console.log(a,b,rest); //1,2,[4,5,6]
}
//不完全解构
{
	let [a,b] = [1,2,3];
}
```
上述的变量全都可以成功赋值，也就是成功解构，但也有无法解构成功的，比如：
```
let [a] = [];
let [b, d,...c] = [1];
console.log(a);  //undefined
console.log(b,d,c); //1,undefined,[]
```
当解构目标在解构的源对应位置找不到值,则无法成功解构,变量的值就会变成`undefined`,...剩余运算符的变量为`[]`.
在实际开发场景中返回的值可能有多种情况,可能你想要的值在某个位置确实没有,那么还可以使用**默认值**。
```
let [a,b = 1] = [1];
console.log(a,b); //1,1
let [c = 1,d = 2] = [undefined,null];
console.log(c,d); //1,null
```
*ES6 内部使用严格相等运算符（===），判断一个位置是否有值。只有当一个数组成员严格等于`undefined`，默认值才会生效*
默认值可以引用解构赋值的其他变量，但该变量必须已经声明。
```
let [a = 1, b = a] = [];     // a=1; b=1
let [a = 1, b = a] = [2];    // a=2; b=2
let [a = 1, b = a] = [1, 2]; // a=1; b=2
let [a = b, b = 1] = [];     // ReferenceError: b is not defined
```
如果解构的源不是数组，就会报错
```
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
```
#### 对象解构赋值
对象解构赋值同样遵循左右互相匹配的规则，类似数组一样有嵌套，默认值等，但要注意的是变量名称需要和对象中的属性值要对应，因为数组的位置相对应来说是有序的，而对象中是无序的，只能通过属性来作为位置查找，如果要使用其它的变量名称，可以使用`:`重新指定变量名称，注意此时引用地址已被新变量接收,`:`左边的变量就没有地址了，再访问的话是空的,在下面示例代码中有对应的写法：
```
//基本
{
  let {a,b} = {a:1,b:2}
  console.log(a,b);
  let {name:newName} = {name:'tony'}
  console.log(name)//
  console.log(newName)//tony
}
//嵌套
{
	let {a,c:}
}
```
#### 字符解构赋值
#### 数组解构赋值